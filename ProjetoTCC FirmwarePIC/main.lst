CCS PCH C Compiler, Version 4.057, 60249               07-May-11 22:45

               Filename: C:\Users\Leandro Honorato\Desktop\ProjetoTCC FirmwarePIC\main.lst

               ROM used: 7786 bytes (24%)
                         Largest free fragment is 24978
               RAM used: 208 (10%) at main() level
                         271 (13%) worst case
               Stack:    13 worst case (10 in main + 3 for interrupts)

*
0000:  GOTO   1B88
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.5
004E:  GOTO   0058
0052:  BTFSC  F9E.5
0054:  GOTO   0504
0058:  MOVFF  0F,00
005C:  MOVFF  10,01
0060:  MOVFF  11,02
0064:  MOVFF  12,03
0068:  MOVFF  13,04
006C:  BSF    0E.7
006E:  MOVFF  0D,FE9
0072:  MOVFF  08,FEA
0076:  MOVFF  09,FE1
007A:  MOVFF  0A,FE2
007E:  MOVFF  0B,FD9
0082:  MOVFF  0C,FDA
0086:  MOVFF  14,FF3
008A:  MOVFF  15,FF4
008E:  MOVFF  16,FFA
0092:  MOVF   05,W
0094:  MOVFF  07,FE0
0098:  MOVFF  06,FD8
009C:  RETFIE 0
.................... //CÓDIGO DE TESTE DA PLATAFORMA DE HARDWARE TCC ZIGBEE - LEANDRO HONORATO 
.................... /*  
.................... * 
.................... * 
.................... */ 
....................  
.................... #include <18F4550.h>  // inclui arquivo de bibliotecas do dispositivo 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc = 10      // essa diretiva precisa vir imediatamente abaixo do include do arquivo do processador 
.................... #fuses HS, NOWDT, PUT, NOLVP, DEBUG, NOPROTECT, NOBROWNOUT 
.................... #use delay(clock=20000000) 
*
05A2:  CLRF   FEA
05A4:  MOVLW  E8
05A6:  MOVWF  FE9
05A8:  MOVF   FEF,W
05AA:  BZ    05C6
05AC:  MOVLW  06
05AE:  MOVWF  01
05B0:  CLRF   00
05B2:  DECFSZ 00,F
05B4:  BRA    05B2
05B6:  DECFSZ 01,F
05B8:  BRA    05B0
05BA:  MOVLW  7B
05BC:  MOVWF  00
05BE:  DECFSZ 00,F
05C0:  BRA    05BE
05C2:  DECFSZ FEF,F
05C4:  BRA    05AC
05C6:  RETLW  00
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, PARITY = N, ERRORS, bits = 8, stop = 1) //Configurações da Serial 
*
0488:  BTFSS  F9E.5
048A:  BRA    0488
048C:  MOVFF  FAB,19
0490:  MOVFF  FAE,01
0494:  BTFSS  19.1
0496:  BRA    049C
0498:  BCF    FAB.4
049A:  BSF    FAB.4
049C:  GOTO   04D2 (RETURN)
....................  
.................... #include "Rotinas_LCD.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_lcd TRUE 
....................  
.................... #define enable    PIN_B3 
.................... #define rs        PIN_B5 
.................... #define rw        PIN_B4 
.................... //#define data      PORT_D 
....................  
.................... void lcd_putc( char c); 
.................... int inverte_bits(int numero); 
.................... void lcd_gotoxy( BYTE x, BYTE y); 
....................  
.................... /* 
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BYTE enable;           // on to an I/O port to gain 
....................            BYTE rs;               // access to the LCD pins. 
....................            BYTE rw;               // The bits are allocated from 
....................            BYTE unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         }; lcd; 
....................  
.................... */ 
.................... /* 
.................... #if defined use_portb_lcd 
....................    //#locate lcd = getenv("sfr:PORTB")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf81 
....................    #else 
....................     #locate lcd = 6 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    //#locate lcd = getenv("sfr:PORTD")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf83 
....................    #else 
....................     #locate lcd = 8 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... #ifndef lcd_type 
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
....................  
....................  
....................  
.................... //BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
.................... BYTE const LCD_INIT_STRING[4] = {0x28, 0xf, 1, 6}; 
....................  
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
....................       lcd.rw = 1; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_cycles(1); 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_us(1); 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_lcd(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
.................... */ 
....................  
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................        
....................       //lcd.data = n; 
....................       n = inverte_bits(n); 
*
0628:  MOVFF  E7,E8
062C:  BRA    05C8
062E:  MOVFF  01,E7
....................       output_d(n); 
0632:  CLRF   F95
0634:  MOVFF  E7,F8C
....................       //delay_cycles(10); 
....................       delay_ms(1); 
0638:  MOVLW  01
063A:  MOVWF  xE8
063C:  RCALL  05A2
....................       //lcd.enable = 1; 
....................       output_high(enable); 
063E:  BCF    F93.3
0640:  BSF    F8A.3
....................       delay_cycles(1); 
0642:  NOP   
....................        
....................       //lcd.enable = 0; 
....................       output_low(enable); 
0644:  BCF    F93.3
0646:  BCF    F8A.3
....................       delay_cycles(1); 
0648:  NOP   
.................... } 
064A:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................        
....................       //lcd.rs = 0; 
....................       output_low(rs); 
064C:  BCF    F93.5
064E:  BCF    F8A.5
....................        
....................       //while ( bit_test(lcd_read_byte(),7) ) ; 
....................       if ( address == 1 ) 
0650:  DECFSZ xE4,W
0652:  BRA    0658
....................       { 
....................          output_high(rs); 
0654:  BCF    F93.5
0656:  BSF    F8A.5
....................       } 
....................       delay_cycles(1); 
0658:  NOP   
....................       //lcd.rw = 0; 
....................       output_low(enable); 
065A:  BCF    F93.3
065C:  BCF    F8A.3
....................       delay_cycles(1); 
065E:  NOP   
....................       //lcd.enable = 0; 
....................       output_low(enable); 
0660:  BCF    F93.3
0662:  BCF    F8A.3
....................       lcd_send_nibble(n >> 4); 
0664:  SWAPF  xE5,W
0666:  MOVWF  xE6
0668:  MOVLW  0F
066A:  ANDWF  xE6,F
066C:  MOVFF  E6,E7
0670:  RCALL  0628
....................       lcd_send_nibble(n & 0x0F); 
0672:  MOVF   xE5,W
0674:  ANDLW  0F
0676:  MOVWF  xE6
0678:  MOVWF  xE7
067A:  RCALL  0628
.................... } 
067C:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................  
....................   output_low(rs); 
*
06A0:  BCF    F93.5
06A2:  BCF    F8A.5
....................   output_low(rw); 
06A4:  BCF    F93.4
06A6:  BCF    F8A.4
....................   output_d(0x00); 
06A8:  CLRF   F95
06AA:  CLRF   F8C
....................   delay_ms(200); 
06AC:  MOVLW  C8
06AE:  MOVWF  xE8
06B0:  RCALL  05A2
....................    
....................  
....................    output_d(0x00); 
06B2:  CLRF   F95
06B4:  CLRF   F8C
....................    //caso reset reiniciar 
....................    //lcd.data=0b0000; 
....................    output_d(0x00); 
06B6:  CLRF   F95
06B8:  CLRF   F8C
....................     
....................    //lcd.enable=1; 
....................    output_high(enable); 
06BA:  BCF    F93.3
06BC:  BSF    F8A.3
....................     
....................    delay_ms(10); 
06BE:  MOVLW  0A
06C0:  MOVWF  xE8
06C2:  RCALL  05A2
....................    //lcd.enable=0; 
....................    output_low(enable); 
06C4:  BCF    F93.3
06C6:  BCF    F8A.3
....................    delay_ms(10); 
06C8:  MOVLW  0A
06CA:  MOVWF  xE8
06CC:  RCALL  05A2
....................     
....................    //4 bits 
....................     
....................    //lcd.data=0b0010; 
....................    output_d(0b01000000); 
06CE:  CLRF   F95
06D0:  MOVLW  40
06D2:  MOVWF  F8C
....................    //lcd.enable=1; 
....................    output_high(enable); 
06D4:  BCF    F93.3
06D6:  BSF    F8A.3
....................    delay_ms(10); 
06D8:  MOVLW  0A
06DA:  MOVWF  xE8
06DC:  RCALL  05A2
....................    //lcd.enable=0; 
....................    output_low(enable); 
06DE:  BCF    F93.3
06E0:  BCF    F8A.3
....................    delay_ms(10); 
06E2:  MOVLW  0A
06E4:  MOVWF  xE8
06E6:  RCALL  05A2
....................     
....................     
....................    //4bits 2 linhas e tal 
....................    //lcd.data=0b0010; 
....................    output_d(0b01000000); 
06E8:  CLRF   F95
06EA:  MOVLW  40
06EC:  MOVWF  F8C
....................    //lcd.enable=1; 
....................    output_high(enable); 
06EE:  BCF    F93.3
06F0:  BSF    F8A.3
....................    delay_ms(10); 
06F2:  MOVLW  0A
06F4:  MOVWF  xE8
06F6:  RCALL  05A2
....................    //lcd.enable=0; 
....................    output_low(enable); 
06F8:  BCF    F93.3
06FA:  BCF    F8A.3
....................    delay_ms(10); 
06FC:  MOVLW  0A
06FE:  MOVWF  xE8
0700:  RCALL  05A2
....................     
....................    //lcd.data=0b1000; 
....................    output_d(0b00010000); 
0702:  CLRF   F95
0704:  MOVLW  10
0706:  MOVWF  F8C
....................    //lcd.enable=1; 
....................    output_high(enable); 
0708:  BCF    F93.3
070A:  BSF    F8A.3
....................    delay_ms(10); 
070C:  MOVLW  0A
070E:  MOVWF  xE8
0710:  RCALL  05A2
....................    //lcd.enable=0; 
....................    output_low(enable); 
0712:  BCF    F93.3
0714:  BCF    F8A.3
....................    delay_ms(10); 
0716:  MOVLW  0A
0718:  MOVWF  xE8
071A:  RCALL  05A2
....................     
....................    //tudo ligado 
....................    //lcd.data=0; 
....................    output_d(0x00); 
071C:  CLRF   F95
071E:  CLRF   F8C
....................    //lcd.enable=1; 
....................    output_high(enable); 
0720:  BCF    F93.3
0722:  BSF    F8A.3
....................    delay_ms(10); 
0724:  MOVLW  0A
0726:  MOVWF  xE8
0728:  RCALL  05A2
....................    //lcd.enable=0; 
....................    output_low(enable); 
072A:  BCF    F93.3
072C:  BCF    F8A.3
....................    delay_ms(10); 
072E:  MOVLW  0A
0730:  MOVWF  xE8
0732:  RCALL  05A2
....................     
....................    //lcd.data=0b1111; 
....................    output_d(0b11110000); 
0734:  CLRF   F95
0736:  MOVLW  F0
0738:  MOVWF  F8C
....................    //lcd.enable=1; 
....................    output_high(enable); 
073A:  BCF    F93.3
073C:  BSF    F8A.3
....................    delay_ms(10); 
073E:  MOVLW  0A
0740:  MOVWF  xE8
0742:  RCALL  05A2
....................    //lcd.enable=0; 
....................    output_low(enable); 
0744:  BCF    F93.3
0746:  BCF    F8A.3
....................    delay_ms(10); 
0748:  MOVLW  0A
074A:  MOVWF  xE8
074C:  RCALL  05A2
....................     
....................    //limpar 
....................    //lcd.data=0; 
....................    output_d(0x00); 
074E:  CLRF   F95
0750:  CLRF   F8C
....................    //lcd.enable=1; 
....................    output_high(enable); 
0752:  BCF    F93.3
0754:  BSF    F8A.3
....................    delay_ms(10); 
0756:  MOVLW  0A
0758:  MOVWF  xE8
075A:  RCALL  05A2
....................    //lcd.enable=0; 
....................    output_low(enable); 
075C:  BCF    F93.3
075E:  BCF    F8A.3
....................    delay_ms(10); 
0760:  MOVLW  0A
0762:  MOVWF  xE8
0764:  RCALL  05A2
....................     
....................    //lcd.data=0b0001; 
....................    output_d(0b10000000); 
0766:  CLRF   F95
0768:  MOVLW  80
076A:  MOVWF  F8C
....................    //lcd.enable=1; 
....................    output_high(enable); 
076C:  BCF    F93.3
076E:  BSF    F8A.3
....................    delay_ms(10); 
0770:  MOVLW  0A
0772:  MOVWF  xE8
0774:  RCALL  05A2
....................    //lcd.enable=0; 
....................    output_low(enable); 
0776:  BCF    F93.3
0778:  BCF    F8A.3
....................    delay_ms(10); 
077A:  MOVLW  0A
077C:  MOVWF  xE8
077E:  RCALL  05A2
....................     
....................    //deslocamento direita esquerda 
....................    //lcd.data=0; 
....................    output_d(0x00); 
0780:  CLRF   F95
0782:  CLRF   F8C
....................    //lcd.enable=1; 
....................    output_high(enable); 
0784:  BCF    F93.3
0786:  BSF    F8A.3
....................    delay_ms(10); 
0788:  MOVLW  0A
078A:  MOVWF  xE8
078C:  RCALL  05A2
....................    //lcd.enable=0; 
....................    output_low(enable); 
078E:  BCF    F93.3
0790:  BCF    F8A.3
....................    delay_ms(10); 
0792:  MOVLW  0A
0794:  MOVWF  xE8
0796:  RCALL  05A2
....................     
....................     
....................    //lcd.data=0b0110; 
....................    output_d(0b01100000); 
0798:  CLRF   F95
079A:  MOVLW  60
079C:  MOVWF  F8C
....................    //lcd.enable=1; 
....................    output_high(enable); 
079E:  BCF    F93.3
07A0:  BSF    F8A.3
....................    delay_ms(10); 
07A2:  MOVLW  0A
07A4:  MOVWF  xE8
07A6:  RCALL  05A2
....................    //lcd.enable=0; 
....................    output_low(enable); 
07A8:  BCF    F93.3
07AA:  BCF    F8A.3
....................    delay_ms(10); 
07AC:  MOVLW  0A
07AE:  MOVWF  xE8
07B0:  RCALL  05A2
....................     
....................    lcd_gotoxy(1,1); 
07B2:  MOVLW  01
07B4:  MOVWF  xE0
07B6:  MOVWF  xE1
07B8:  RCALL  067E
....................  
.................... } 
07BA:  GOTO   1BCE (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
067E:  DECFSZ xE1,W
0680:  BRA    0684
0682:  BRA    068A
....................      address=lcd_line_two; 
0684:  MOVLW  40
0686:  MOVWF  xE2
....................    else 
0688:  BRA    068C
....................      address=0; 
068A:  CLRF   xE2
....................    address+=x-1; 
068C:  MOVLW  01
068E:  SUBWF  xE0,W
0690:  ADDWF  xE2,F
....................    lcd_send_byte(0,0x80|address); 
0692:  MOVF   xE2,W
0694:  IORLW  80
0696:  MOVWF  xE3
0698:  CLRF   xE4
069A:  MOVWF  xE5
069C:  RCALL  064C
.................... } 
069E:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
*
07BE:  MOVF   xDF,W
07C0:  XORLW  0C
07C2:  BZ    07CE
07C4:  XORLW  06
07C6:  BZ    07DE
07C8:  XORLW  02
07CA:  BZ    07EA
07CC:  BRA    07F4
....................      case '\f'   : lcd_send_byte(0,1); 
07CE:  CLRF   xE4
07D0:  MOVLW  01
07D2:  MOVWF  xE5
07D4:  RCALL  064C
....................                    delay_ms(2); 
07D6:  MOVLW  02
07D8:  MOVWF  xE8
07DA:  RCALL  05A2
....................                                            break; 
07DC:  BRA    0800
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
07DE:  MOVLW  01
07E0:  MOVWF  xE0
07E2:  MOVLW  02
07E4:  MOVWF  xE1
07E6:  RCALL  067E
07E8:  BRA    0800
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
07EA:  CLRF   xE4
07EC:  MOVLW  10
07EE:  MOVWF  xE5
07F0:  RCALL  064C
07F2:  BRA    0800
....................      default     : lcd_send_byte(1,c);     break; 
07F4:  MOVLW  01
07F6:  MOVWF  xE4
07F8:  MOVFF  DF,E5
07FC:  RCALL  064C
07FE:  BRA    0800
....................    } 
.................... } 
0800:  RETLW  00
....................  
....................  
.................... /* 
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
.................... */ 
....................  
.................... int inverte_bits(int numero){ 
....................    int byte_invertido; 
....................    int count; 
....................    int temp = 8; 
*
05C8:  MOVLW  08
05CA:  MOVWF  xEB
....................    for(count = 0; count <8; count++){ 
05CC:  CLRF   xEA
05CE:  MOVF   xEA,W
05D0:  SUBLW  07
05D2:  BNC   0620
....................    temp--; 
05D4:  DECF   xEB,F
....................    if(bit_test(numero,count)) 
05D6:  MOVFF  E8,00
05DA:  MOVF   xEA,W
05DC:  MOVWF  01
05DE:  BZ    05E8
05E0:  BCF    FD8.0
05E2:  RRCF   00,F
05E4:  DECFSZ 01,F
05E6:  BRA    05E0
05E8:  BTFSS  00.0
05EA:  BRA    0604
....................    { 
....................       bit_set(byte_invertido,temp); 
05EC:  MOVLW  01
05EE:  MOVWF  00
05F0:  MOVF   xEB,W
05F2:  MOVWF  01
05F4:  BZ    05FE
05F6:  BCF    FD8.0
05F8:  RLCF   00,F
05FA:  DECFSZ 01,F
05FC:  BRA    05F6
05FE:  MOVF   00,W
0600:  IORWF  xE9,F
....................    }else 
0602:  BRA    061C
....................       bit_clear(byte_invertido,temp); 
0604:  MOVLW  01
0606:  MOVWF  00
0608:  MOVF   xEB,W
060A:  MOVWF  01
060C:  BZ    0616
060E:  BCF    FD8.0
0610:  RLCF   00,F
0612:  DECFSZ 01,F
0614:  BRA    060E
0616:  MOVF   00,W
0618:  XORLW  FF
061A:  ANDWF  xE9,F
....................    } 
061C:  INCF   xEA,F
061E:  BRA    05CE
....................    //byte_invertido = (byte_invertido << 4); 
....................    return byte_invertido; 
0620:  MOVFF  E9,01
.................... } 
0624:  GOTO   062E (RETURN)
....................  
.................... void clearLine1() 
.................... { 
....................    lcd_gotoxy(1,1); 
*
0802:  MOVLW  01
0804:  MOVWF  xE0
0806:  MOVWF  xE1
0808:  RCALL  067E
....................    printf(lcd_putc,"                "); 
080A:  CLRF   xDD
080C:  MOVF   xDD,W
080E:  RCALL  009E
0810:  INCF   xDD,F
0812:  MOVWF  00
0814:  MOVWF  xDF
0816:  RCALL  07BE
0818:  MOVLW  10
081A:  SUBWF  xDD,W
081C:  BNZ   080C
.................... } 
081E:  GOTO   0844 (RETURN)
....................  
.................... void clearLine2() 
.................... { 
....................    lcd_gotoxy(1,2); 
0822:  MOVLW  01
0824:  MOVWF  xE0
0826:  MOVLW  02
0828:  MOVWF  xE1
082A:  RCALL  067E
....................    printf(lcd_putc,"                "); 
082C:  CLRF   xDD
082E:  MOVF   xDD,W
0830:  RCALL  009E
0832:  INCF   xDD,F
0834:  MOVWF  00
0836:  MOVWF  xDF
0838:  RCALL  07BE
083A:  MOVLW  10
083C:  SUBWF  xDD,W
083E:  BNZ   082E
.................... } 
0840:  RETLW  00
....................  
.................... void clearLCD() 
.................... { 
....................    clearLine1(); 
0842:  BRA    0802
....................    clearLine2(); 
0844:  RCALL  0822
.................... } 
0846:  RETLW  00
....................  
....................  
....................  
.................... #include "ADC_Read.c" 
.................... //#include "ADC_Read.h" 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float32 atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
*
08A0:  MOVFF  FF,103
08A4:  MOVFF  FE,102
08A8:  MOVFF  101,03
08AC:  MOVLB  1
08AE:  MOVFF  100,FE9
08B2:  MOVFF  101,FEA
08B6:  MOVF   FEF,F
08B8:  BZ    08EA
....................      *s = *s2; 
08BA:  MOVFF  100,FE9
08BE:  MOVFF  101,FEA
08C2:  MOVFF  FEF,106
08C6:  MOVFF  103,FEA
08CA:  MOVFF  102,FE9
08CE:  MOVFF  106,FEF
....................   } 
08D2:  MOVFF  103,03
08D6:  MOVF   x02,W
08D8:  INCF   x02,F
08DA:  BTFSC  FD8.2
08DC:  INCF   x03,F
08DE:  INCF   x00,F
08E0:  BTFSC  FD8.2
08E2:  INCF   x01,F
08E4:  MOVLB  0
08E6:  BRA    08A8
08E8:  MOVLB  1
....................   *s = *s2; 
08EA:  MOVFF  100,FE9
08EE:  MOVFF  101,FEA
08F2:  MOVFF  FEF,106
08F6:  MOVFF  103,FEA
08FA:  MOVFF  102,FE9
08FE:  MOVFF  106,FEF
....................   return(s1); 
0902:  MOVLB  0
0904:  MOVFF  FE,01
0908:  MOVFF  FF,02
.................... } 
090C:  RETLW  00
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0A14:  MOVFF  DD,FE9
0A18:  MOVFF  DE,FEA
0A1C:  MOVFF  FEF,E1
0A20:  MOVFF  E0,03
0A24:  MOVFF  DF,FE9
0A28:  MOVFF  E0,FEA
0A2C:  MOVF   FEF,W
0A2E:  SUBWF  xE1,W
0A30:  BNZ   0A5C
....................       if (*s1 == '\0') 
0A32:  MOVFF  DE,03
0A36:  MOVFF  DD,FE9
0A3A:  MOVFF  03,FEA
0A3E:  MOVF   FEF,F
0A40:  BNZ   0A48
....................          return(0); 
0A42:  MOVLW  00
0A44:  MOVWF  01
0A46:  BRA    0A86
0A48:  MOVFF  DE,03
0A4C:  MOVF   xDD,W
0A4E:  INCF   xDD,F
0A50:  BTFSC  FD8.2
0A52:  INCF   xDE,F
0A54:  INCF   xDF,F
0A56:  BTFSC  FD8.2
0A58:  INCF   xE0,F
0A5A:  BRA    0A14
....................    return((*s1 < *s2) ? -1: 1); 
0A5C:  MOVFF  DE,03
0A60:  MOVFF  DD,FE9
0A64:  MOVFF  DE,FEA
0A68:  MOVFF  FEF,E1
0A6C:  MOVFF  E0,03
0A70:  MOVFF  DF,FE9
0A74:  MOVFF  E0,FEA
0A78:  MOVF   FEF,W
0A7A:  SUBWF  xE1,W
0A7C:  BC    0A82
0A7E:  MOVLW  FF
0A80:  BRA    0A84
0A82:  MOVLW  01
0A84:  MOVWF  01
.................... } 
0A86:  RETLW  00
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................  #cdebug5      
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
13DA:  CLRF   xD4
....................    sign = 0; 
13DC:  CLRF   xD2
....................    base = 10; 
13DE:  MOVLW  0A
13E0:  MOVWF  xD3
....................    result = 0; 
13E2:  CLRF   xD1
....................  
....................    if (!s) 
13E4:  MOVF   xCF,W
13E6:  IORWF  xD0,W
13E8:  BNZ   13F0
....................       return 0; 
13EA:  MOVLW  00
13EC:  MOVWF  01
13EE:  BRA    1572
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
13F0:  MOVF   xD4,W
13F2:  INCF   xD4,F
13F4:  CLRF   03
13F6:  ADDWF  xCF,W
13F8:  MOVWF  FE9
13FA:  MOVF   xD0,W
13FC:  ADDWFC 03,W
13FE:  MOVWF  FEA
1400:  MOVFF  FEF,D5
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
1404:  MOVF   xD5,W
1406:  SUBLW  2D
1408:  BNZ   1424
....................    { 
....................       sign = 1;         // Set the sign to negative 
140A:  MOVLW  01
140C:  MOVWF  xD2
....................       c = s[index++]; 
140E:  MOVF   xD4,W
1410:  INCF   xD4,F
1412:  CLRF   03
1414:  ADDWF  xCF,W
1416:  MOVWF  FE9
1418:  MOVF   xD0,W
141A:  ADDWFC 03,W
141C:  MOVWF  FEA
141E:  MOVFF  FEF,D5
....................    } 
....................    else if (c == '+') 
1422:  BRA    143E
1424:  MOVF   xD5,W
1426:  SUBLW  2B
1428:  BNZ   143E
....................    { 
....................       c = s[index++]; 
142A:  MOVF   xD4,W
142C:  INCF   xD4,F
142E:  CLRF   03
1430:  ADDWF  xCF,W
1432:  MOVWF  FE9
1434:  MOVF   xD0,W
1436:  ADDWFC 03,W
1438:  MOVWF  FEA
143A:  MOVFF  FEF,D5
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
143E:  MOVF   xD5,W
1440:  SUBLW  2F
1442:  BTFSC  FD8.0
1444:  BRA    1562
1446:  MOVF   xD5,W
1448:  SUBLW  39
144A:  BTFSS  FD8.0
144C:  BRA    1562
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
144E:  MOVF   xD5,W
1450:  SUBLW  30
1452:  BNZ   1496
1454:  CLRF   03
1456:  MOVF   xD4,W
1458:  ADDWF  xCF,W
145A:  MOVWF  FE9
145C:  MOVF   xD0,W
145E:  ADDWFC 03,W
1460:  MOVWF  FEA
1462:  MOVF   FEF,W
1464:  SUBLW  78
1466:  BZ    147C
1468:  CLRF   03
146A:  MOVF   xD4,W
146C:  ADDWF  xCF,W
146E:  MOVWF  FE9
1470:  MOVF   xD0,W
1472:  ADDWFC 03,W
1474:  MOVWF  FEA
1476:  MOVF   FEF,W
1478:  SUBLW  58
147A:  BNZ   1496
....................       { 
....................          base = 16; 
147C:  MOVLW  10
147E:  MOVWF  xD3
....................          index++; 
1480:  INCF   xD4,F
....................          c = s[index++]; 
1482:  MOVF   xD4,W
1484:  INCF   xD4,F
1486:  CLRF   03
1488:  ADDWF  xCF,W
148A:  MOVWF  FE9
148C:  MOVF   xD0,W
148E:  ADDWFC 03,W
1490:  MOVWF  FEA
1492:  MOVFF  FEF,D5
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1496:  MOVF   xD3,W
1498:  SUBLW  0A
149A:  BNZ   14D2
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
149C:  MOVF   xD5,W
149E:  SUBLW  2F
14A0:  BC    14D0
14A2:  MOVF   xD5,W
14A4:  SUBLW  39
14A6:  BNC   14D0
....................             result = 10*result + (c - '0'); 
14A8:  MOVLW  0A
14AA:  MOVWF  xD6
14AC:  MOVFF  D1,D7
14B0:  BRA    138E
14B2:  MOVLW  30
14B4:  SUBWF  xD5,W
14B6:  ADDWF  01,W
14B8:  MOVWF  xD1
....................             c = s[index++]; 
14BA:  MOVF   xD4,W
14BC:  INCF   xD4,F
14BE:  CLRF   03
14C0:  ADDWF  xCF,W
14C2:  MOVWF  FE9
14C4:  MOVF   xD0,W
14C6:  ADDWFC 03,W
14C8:  MOVWF  FEA
14CA:  MOVFF  FEF,D5
....................          } 
14CE:  BRA    149C
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
14D0:  BRA    1562
14D2:  MOVF   xD3,W
14D4:  SUBLW  10
14D6:  BNZ   1562
....................       { 
....................          c = toupper(c); 
14D8:  MOVF   xD5,W
14DA:  SUBLW  60
14DC:  BC    14EA
14DE:  MOVF   xD5,W
14E0:  SUBLW  7A
14E2:  BNC   14EA
14E4:  MOVF   xD5,W
14E6:  ANDLW  DF
14E8:  BRA    14EC
14EA:  MOVF   xD5,W
14EC:  MOVWF  xD5
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
14EE:  MOVF   xD5,W
14F0:  SUBLW  2F
14F2:  BC    14FA
14F4:  MOVF   xD5,W
14F6:  SUBLW  39
14F8:  BC    1506
14FA:  MOVF   xD5,W
14FC:  SUBLW  40
14FE:  BC    1562
1500:  MOVF   xD5,W
1502:  SUBLW  46
1504:  BNC   1562
....................             if (c >= '0' && c <= '9') 
1506:  MOVF   xD5,W
1508:  SUBLW  2F
150A:  BC    1524
150C:  MOVF   xD5,W
150E:  SUBLW  39
1510:  BNC   1524
....................                result = (result << 4) + (c - '0'); 
1512:  SWAPF  xD1,W
1514:  MOVWF  xD6
1516:  MOVLW  F0
1518:  ANDWF  xD6,F
151A:  MOVLW  30
151C:  SUBWF  xD5,W
151E:  ADDWF  xD6,W
1520:  MOVWF  xD1
....................             else 
1522:  BRA    1536
....................                result = (result << 4) + (c - 'A' + 10); 
1524:  SWAPF  xD1,W
1526:  MOVWF  xD6
1528:  MOVLW  F0
152A:  ANDWF  xD6,F
152C:  MOVLW  41
152E:  SUBWF  xD5,W
1530:  ADDLW  0A
1532:  ADDWF  xD6,W
1534:  MOVWF  xD1
....................  
....................             c = s[index++]; 
1536:  MOVF   xD4,W
1538:  INCF   xD4,F
153A:  CLRF   03
153C:  ADDWF  xCF,W
153E:  MOVWF  FE9
1540:  MOVF   xD0,W
1542:  ADDWFC 03,W
1544:  MOVWF  FEA
1546:  MOVFF  FEF,D5
....................             c = toupper(c); 
154A:  MOVF   xD5,W
154C:  SUBLW  60
154E:  BC    155C
1550:  MOVF   xD5,W
1552:  SUBLW  7A
1554:  BNC   155C
1556:  MOVF   xD5,W
1558:  ANDLW  DF
155A:  BRA    155E
155C:  MOVF   xD5,W
155E:  MOVWF  xD5
....................          } 
1560:  BRA    14EE
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
1562:  DECFSZ xD2,W
1564:  BRA    156E
1566:  MOVF   xD3,W
1568:  SUBLW  0A
156A:  BNZ   156E
....................        result = -result; 
156C:  NEGF   xD1
....................  
....................    return(result); 
156E:  MOVFF  D1,01
.................... } 
1572:  GOTO   1812 (RETURN)
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
*
0E80:  MOVLW  01
0E82:  MOVWF  xDD
0E84:  CLRF   xDE
0E86:  CLRF   xDF
0E88:  CLRF   xE0
....................      unsigned int8 i,sign=0,cnt=0; 
0E8A:  CLRF   xE2
0E8C:  CLRF   xE3
....................      char c; 
....................  
....................      if(num<0) { 
0E8E:  BTFSC  xD9.7
0E90:  BRA    0E94
0E92:  BRA    0EC4
....................          sign=1;        // Check for negative number 
0E94:  MOVLW  01
0E96:  MOVWF  xE2
....................          num*=-1; 
0E98:  MOVFF  D9,E8
0E9C:  MOVFF  D8,E7
0EA0:  MOVFF  D7,E6
0EA4:  MOVFF  D6,E5
0EA8:  MOVLW  FF
0EAA:  MOVWF  xEC
0EAC:  MOVWF  xEB
0EAE:  MOVWF  xEA
0EB0:  MOVWF  xE9
0EB2:  BRA    0D5A
0EB4:  MOVFF  03,D9
0EB8:  MOVFF  02,D8
0EBC:  MOVFF  01,D7
0EC0:  MOVFF  00,D6
....................      } 
....................  
....................      while(temp>0) { 
0EC4:  MOVF   xDD,F
0EC6:  BNZ   0ED4
0EC8:  MOVF   xDE,F
0ECA:  BNZ   0ED4
0ECC:  MOVF   xDF,F
0ECE:  BNZ   0ED4
0ED0:  MOVF   xE0,F
0ED2:  BZ    0FBA
....................          temp=(num/base); 
0ED4:  MOVFF  D9,EC
0ED8:  MOVFF  D8,EB
0EDC:  MOVFF  D7,EA
0EE0:  MOVFF  D6,E9
0EE4:  CLRF   xF0
0EE6:  CLRF   xEF
0EE8:  CLRF   xEE
0EEA:  MOVFF  DA,ED
0EEE:  RCALL  0DB0
0EF0:  MOVFF  03,E0
0EF4:  MOVFF  02,DF
0EF8:  MOVFF  01,DE
0EFC:  MOVFF  00,DD
....................          s[cnt]=(num%base)+'0';    // Conversion 
0F00:  CLRF   03
0F02:  MOVF   xE3,W
0F04:  ADDWF  xDB,W
0F06:  MOVWF  01
0F08:  MOVF   xDC,W
0F0A:  ADDWFC 03,F
0F0C:  MOVFF  01,E5
0F10:  MOVFF  03,E6
0F14:  MOVFF  FEA,E8
0F18:  MOVFF  FE9,E7
0F1C:  MOVFF  D9,EC
0F20:  MOVFF  D8,EB
0F24:  MOVFF  D7,EA
0F28:  MOVFF  D6,E9
0F2C:  CLRF   xF0
0F2E:  CLRF   xEF
0F30:  CLRF   xEE
0F32:  MOVFF  DA,ED
0F36:  RCALL  0DB0
0F38:  MOVFF  FEF,00
0F3C:  MOVFF  FEC,01
0F40:  MOVFF  FEC,02
0F44:  MOVFF  FEC,03
0F48:  MOVFF  E8,FEA
0F4C:  MOVFF  E7,FE9
0F50:  MOVFF  03,EC
0F54:  MOVFF  02,EB
0F58:  MOVFF  01,EA
0F5C:  MOVFF  00,E9
0F60:  MOVLW  30
0F62:  ADDWF  00,W
0F64:  MOVWF  00
0F66:  MOVLW  00
0F68:  ADDWFC 01,W
0F6A:  MOVLW  00
0F6C:  ADDWFC 02,W
0F6E:  MOVLW  00
0F70:  ADDWFC 03,W
0F72:  MOVFF  E6,FEA
0F76:  MOVFF  E5,FE9
0F7A:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
0F7E:  CLRF   03
0F80:  MOVF   xE3,W
0F82:  ADDWF  xDB,W
0F84:  MOVWF  FE9
0F86:  MOVF   xDC,W
0F88:  ADDWFC 03,W
0F8A:  MOVWF  FEA
0F8C:  MOVF   FEF,W
0F8E:  SUBLW  39
0F90:  BC    0FA6
....................             s[cnt]+=0x7; 
0F92:  CLRF   03
0F94:  MOVF   xE3,W
0F96:  ADDWF  xDB,W
0F98:  MOVWF  FE9
0F9A:  MOVF   xDC,W
0F9C:  ADDWFC 03,W
0F9E:  MOVWF  FEA
0FA0:  MOVLW  07
0FA2:  ADDWF  FEF,W
0FA4:  MOVWF  FEF
....................  
....................          cnt++; 
0FA6:  INCF   xE3,F
....................          num=temp; 
0FA8:  MOVFF  E0,D9
0FAC:  MOVFF  DF,D8
0FB0:  MOVFF  DE,D7
0FB4:  MOVFF  DD,D6
....................      } 
0FB8:  BRA    0EC4
....................  
....................      if(sign==1) { 
0FBA:  DECFSZ xE2,W
0FBC:  BRA    0FD2
....................          s[cnt]=0x2D;      // Negative sign 
0FBE:  CLRF   03
0FC0:  MOVF   xE3,W
0FC2:  ADDWF  xDB,W
0FC4:  MOVWF  FE9
0FC6:  MOVF   xDC,W
0FC8:  ADDWFC 03,W
0FCA:  MOVWF  FEA
0FCC:  MOVLW  2D
0FCE:  MOVWF  FEF
....................          cnt++; 
0FD0:  INCF   xE3,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
0FD2:  CLRF   xE1
0FD4:  BCF    FD8.0
0FD6:  RRCF   xE3,W
0FD8:  SUBWF  xE1,W
0FDA:  BC    103A
....................  
....................          c=s[i]; 
0FDC:  CLRF   03
0FDE:  MOVF   xE1,W
0FE0:  ADDWF  xDB,W
0FE2:  MOVWF  FE9
0FE4:  MOVF   xDC,W
0FE6:  ADDWFC 03,W
0FE8:  MOVWF  FEA
0FEA:  MOVFF  FEF,E4
....................          s[i]=s[cnt-i-1];        // Reverse the number 
0FEE:  CLRF   03
0FF0:  MOVF   xE1,W
0FF2:  ADDWF  xDB,W
0FF4:  MOVWF  01
0FF6:  MOVF   xDC,W
0FF8:  ADDWFC 03,F
0FFA:  MOVFF  03,E6
0FFE:  MOVF   xE1,W
1000:  SUBWF  xE3,W
1002:  ADDLW  FF
1004:  CLRF   03
1006:  ADDWF  xDB,W
1008:  MOVWF  FE9
100A:  MOVF   xDC,W
100C:  ADDWFC 03,W
100E:  MOVWF  FEA
1010:  MOVFF  FEF,E9
1014:  MOVFF  E6,FEA
1018:  MOVFF  01,FE9
101C:  MOVFF  E9,FEF
....................          s[cnt-i-1]=c; 
1020:  MOVF   xE1,W
1022:  SUBWF  xE3,W
1024:  ADDLW  FF
1026:  CLRF   03
1028:  ADDWF  xDB,W
102A:  MOVWF  FE9
102C:  MOVF   xDC,W
102E:  ADDWFC 03,W
1030:  MOVWF  FEA
1032:  MOVFF  E4,FEF
....................      } 
1036:  INCF   xE1,F
1038:  BRA    0FD4
....................      s[cnt]='\0';     // End the string 
103A:  CLRF   03
103C:  MOVF   xE3,W
103E:  ADDWF  xDB,W
1040:  MOVWF  FE9
1042:  MOVF   xDC,W
1044:  ADDWFC 03,W
1046:  MOVWF  FEA
1048:  CLRF   FEF
....................      return s; 
104A:  MOVFF  DB,01
104E:  MOVFF  DC,02
.................... } 
1052:  GOTO   10A0 (RETURN)
....................  
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr) { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... void ler_canal_AD_para_int32 (int8 canal, int32 * p_valor) 
.................... { 
....................    set_adc_channel(canal);  //escolhe canal 
*
10A2:  RLCF   xCE,W
10A4:  MOVWF  00
10A6:  RLCF   00,F
10A8:  MOVLW  FC
10AA:  ANDWF  00,F
10AC:  MOVF   FC2,W
10AE:  ANDLW  C3
10B0:  IORWF  00,W
10B2:  MOVWF  FC2
....................    delay_ms(50);             //espera um tempo para a tensão se estabilizar 
10B4:  MOVLW  32
10B6:  MOVWF  xE8
10B8:  CALL   05A2
....................    *p_valor = read_adc();      //inicia a conversão espera ela ser concluida e retorna o valor convertido 
10BC:  MOVFF  D0,03
10C0:  MOVFF  CF,FE9
10C4:  MOVFF  D0,FEA
10C8:  BSF    FC2.1
10CA:  BTFSC  FC2.1
10CC:  BRA    10CA
10CE:  MOVFF  FC3,FEF
10D2:  MOVFF  FC4,FEC
10D6:  CLRF   FEC
10D8:  CLRF   FEC
.................... } 
10DA:  GOTO   1DE6 (RETURN)
....................  
.................... void ler_canal_AD_para_puint8 (int8 canal, int8 * p_valorChar) 
.................... { 
....................     
....................    int32 valorLeitura; 
....................    set_adc_channel(canal);  //escolhe canal 
*
1056:  RLCF   xCF,W
1058:  MOVWF  00
105A:  RLCF   00,F
105C:  MOVLW  FC
105E:  ANDWF  00,F
1060:  MOVF   FC2,W
1062:  ANDLW  C3
1064:  IORWF  00,W
1066:  MOVWF  FC2
....................    delay_ms(50);  //espera um tempo para a tensão se estabilizar 
1068:  MOVLW  32
106A:  MOVWF  xE8
106C:  CALL   05A2
....................    valorLeitura = read_adc();      //inicia a conversão espera ela ser concluida e retorna o valor convertido 
1070:  BSF    FC2.1
1072:  BTFSC  FC2.1
1074:  BRA    1072
1076:  MOVFF  FC3,D2
107A:  MOVFF  FC4,D3
107E:  CLRF   xD4
1080:  CLRF   xD5
....................    itoa(valorLeitura,10,p_valorChar); 
1082:  MOVFF  D5,D9
1086:  MOVFF  D4,D8
108A:  MOVFF  D3,D7
108E:  MOVFF  D2,D6
1092:  MOVLW  0A
1094:  MOVWF  xDA
1096:  MOVFF  D1,DC
109A:  MOVFF  D0,DB
109E:  BRA    0E80
.................... } 
10A0:  RETLW  00
....................  
.................... void init_ADC() 
.................... { 
....................    setup_adc(ADC_CLOCK_DIV_32);   //configura conversor AD 
*
0D44:  BCF    FC0.0
0D46:  BSF    FC0.1
0D48:  BCF    FC0.2
0D4A:  BSF    FC0.7
0D4C:  BSF    FC2.0
....................    setup_adc_ports(AN0_TO_AN10);   //escolhe pinos de entradas analógicas 
0D4E:  MOVF   FC1,W
0D50:  ANDLW  C0
0D52:  IORLW  04
0D54:  MOVWF  FC1
.................... } 
0D56:  GOTO   1D4A (RETURN)
....................  
.................... #include "BibliotecaZigBee.c" 
.................... /* 
.................... *  Biblioteca de Funções para o Módulo ZigBee ZNet 2.5 
.................... */ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float32 atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................  #cdebug5      
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr) { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAX_BUFFER 50 //Tamanho do Buffer de recepção Serial 
.................... #define MAX_PACOTE 30 //Tamanho do Array onde as respostas são armazenadas 
....................  
.................... //#include<stdlib.h> //Para usar atoi(); //Função de conversão de string para int 
....................  
.................... int8 buffer_resposta_zigbee [MAX_BUFFER]; //Buffer que recebe os dados e comandos pela serial 
.................... int pacoteRecebido [MAX_PACOTE]; //array para armazenar os comandos recebidos na medida que forem retirados do buffer (ver funções buscar_dados e buscar_respostas) 
.................... //int enderecos[10][12]; //matriz para guardar os endereços obtidos após o comando de Discovery 
....................  
.................... int contador_escrita; //Variável para saber onde escrever no Buffer de recepção Serial (resposta_zigbee) 
.................... int contador_leitura; //Variável para saber onde ler no Buffer de recepção Serial (resposta_zigbee) 
.................... char comandoREADR[7]; 
.................... char comandoSET_NAME[7]; 
.................... char comandoREMOTO[7]; 
....................  
.................... typedef enum _TipoPacote 
.................... { 
....................    READR, 
....................    SET_NAME, 
....................    COMANDO_REMOTO, 
....................    PACOTE_NAO_IDENTIFICADO 
.................... }TipoPacote; 
....................  
.................... typedef struct _pacote 
.................... { 
....................    TipoPacote tipoPacote; 
....................    char informacao[15]; 
.................... } Pacote; 
....................  
.................... /** 
....................  * Esta função deve ser chamada sempre que chegar dados pela serial 
....................  * Armazena os dados que estão chegando no array resposta_zigbee 
....................  */ 
.................... void interrupcao_serial()  //TESTADO 
.................... { 
....................    int8 temp; 
....................    while( kbhit() ) 
....................    { 
*
04CC:  BTFSS  F9E.5
04CE:  BRA    0500
....................          temp = getc(); 
04D0:  BRA    0488
04D2:  MOVFF  01,109
....................          buffer_resposta_zigbee[contador_escrita] = temp; 
04D6:  CLRF   03
04D8:  MOVF   x70,W
04DA:  ADDLW  20
04DC:  MOVWF  FE9
04DE:  MOVLW  00
04E0:  ADDWFC 03,W
04E2:  MOVWF  FEA
04E4:  MOVFF  109,FEF
....................          contador_escrita = (contador_escrita+1)%MAX_BUFFER; //Incremento circular: quando chegar no final do array, volta a escrever no início  
04E8:  MOVLW  01
04EA:  ADDWF  x70,W
04EC:  MOVLB  1
04EE:  MOVWF  x0B
04F0:  MOVWF  x0C
04F2:  MOVLW  32
04F4:  MOVWF  x0D
04F6:  MOVLB  0
04F8:  RCALL  04A0
04FA:  MOVFF  00,70
....................    } 
04FE:  BRA    04CC
.................... } 
0500:  GOTO   0506 (RETURN)
....................  
.................... void zerarBufferPacoteRecebido() 
.................... { 
....................    int contador; 
....................    for(contador = 0; contador < MAX_PACOTE; contador++) 
*
0880:  CLRF   xFE
0882:  MOVF   xFE,W
0884:  SUBLW  1D
0886:  BNC   089C
....................    { 
....................       pacoteRecebido[contador] = 0; 
0888:  CLRF   03
088A:  MOVF   xFE,W
088C:  ADDLW  52
088E:  MOVWF  FE9
0890:  MOVLW  00
0892:  ADDWFC 03,W
0894:  MOVWF  FEA
0896:  CLRF   FEF
....................    } 
0898:  INCF   xFE,F
089A:  BRA    0882
.................... } 
089C:  GOTO   0980 (RETURN)
....................  
.................... int1 chegouPacote() 
.................... { 
....................    int8 i; 
....................    int8 temp_pacote[MAX_PACOTE]; 
....................    int8 contadorPacote = 0;    
*
090E:  CLRF   xFD
....................     
....................     
....................    for(i = contador_leitura; buffer_resposta_zigbee[i] != 0 ; i=(i+1)%MAX_BUFFER) 
0910:  MOVFF  71,DE
0914:  CLRF   03
0916:  MOVF   xDE,W
0918:  ADDLW  20
091A:  MOVWF  FE9
091C:  MOVLW  00
091E:  ADDWFC 03,W
0920:  MOVWF  FEA
0922:  MOVF   FEF,F
0924:  BZ    09F2
....................    { 
....................       if( buffer_resposta_zigbee[i] == '\r' ) 
0926:  CLRF   03
0928:  MOVF   xDE,W
092A:  ADDLW  20
092C:  MOVWF  FE9
092E:  MOVLW  00
0930:  ADDWFC 03,W
0932:  MOVWF  FEA
0934:  MOVF   FEF,W
0936:  SUBLW  0D
0938:  BNZ   0998
....................       { 
....................          buffer_resposta_zigbee[i] = 0; //Finaliza a string 
093A:  CLRF   03
093C:  MOVF   xDE,W
093E:  ADDLW  20
0940:  MOVWF  FE9
0942:  MOVLW  00
0944:  ADDWFC 03,W
0946:  MOVWF  FEA
0948:  CLRF   FEF
....................          temp_pacote[contadorPacote] = 0; 
094A:  CLRF   03
094C:  MOVF   xFD,W
094E:  ADDLW  DF
0950:  MOVWF  FE9
0952:  MOVLW  00
0954:  ADDWFC 03,W
0956:  MOVWF  FEA
0958:  CLRF   FEF
....................           
....................          contador_leitura = (i + 1)%MAX_BUFFER; 
095A:  MOVLW  01
095C:  ADDWF  xDE,W
095E:  MOVWF  xFF
0960:  CLRF   18
0962:  BTFSC  FF2.7
0964:  BSF    18.7
0966:  BCF    FF2.7
0968:  MOVFF  FE8,10C
096C:  MOVLW  32
096E:  MOVLB  1
0970:  MOVWF  x0D
0972:  MOVLB  0
0974:  RCALL  04A0
0976:  BTFSC  18.7
0978:  BSF    FF2.7
097A:  MOVFF  00,71
....................           
....................          zerarBufferPacoteRecebido(); 
097E:  BRA    0880
....................           
....................          strcopy(pacoteRecebido, temp_pacote); 
0980:  CLRF   xFF
0982:  MOVLW  52
0984:  MOVWF  xFE
0986:  MOVLB  1
0988:  CLRF   x01
098A:  MOVLW  DF
098C:  MOVWF  x00
098E:  MOVLB  0
0990:  RCALL  08A0
....................           
....................           
....................          return 1; 
0992:  MOVLW  01
0994:  MOVWF  01
0996:  BRA    09F6
....................       } 
....................       temp_pacote[contadorPacote] = buffer_resposta_zigbee[i]; 
0998:  CLRF   03
099A:  MOVF   xFD,W
099C:  ADDLW  DF
099E:  MOVWF  01
09A0:  MOVLW  00
09A2:  ADDWFC 03,F
09A4:  MOVFF  03,FF
09A8:  CLRF   03
09AA:  MOVF   xDE,W
09AC:  ADDLW  20
09AE:  MOVWF  FE9
09B0:  MOVLW  00
09B2:  ADDWFC 03,W
09B4:  MOVWF  FEA
09B6:  MOVFF  FEF,100
09BA:  MOVLB  1
09BC:  MOVFF  FF,FEA
09C0:  MOVFF  01,FE9
09C4:  MOVFF  100,FEF
....................       contadorPacote++; 
09C8:  MOVLB  0
09CA:  INCF   xFD,F
....................    } 
09CC:  MOVLW  01
09CE:  ADDWF  xDE,W
09D0:  MOVWF  xFF
09D2:  CLRF   18
09D4:  BTFSC  FF2.7
09D6:  BSF    18.7
09D8:  BCF    FF2.7
09DA:  MOVFF  FE8,10C
09DE:  MOVLW  32
09E0:  MOVLB  1
09E2:  MOVWF  x0D
09E4:  MOVLB  0
09E6:  RCALL  04A0
09E8:  BTFSC  18.7
09EA:  BSF    FF2.7
09EC:  MOVFF  00,DE
09F0:  BRA    0914
....................    return 0; 
09F2:  MOVLW  00
09F4:  MOVWF  01
.................... } 
09F6:  RETLW  00
....................  
.................... /** 
....................  * Função para inicializar as variáveis de controle globais. 
....................  * 
....................  */ 
.................... void inicializar_variaveis(){ //TESTADO 
....................    contador_leitura = 0; 
*
0528:  CLRF   x71
....................    contador_escrita = 0; 
052A:  CLRF   x70
....................     
....................    sprintf(comandoREADR, "#READR"); 
052C:  CLRF   x88
052E:  MOVLW  72
0530:  MOVWF  x87
0532:  CLRF   xCE
0534:  MOVF   xCE,W
0536:  RCALL  00CA
0538:  INCF   xCE,F
053A:  MOVWF  00
053C:  MOVWF  xCF
053E:  RCALL  050C
0540:  MOVLW  06
0542:  SUBWF  xCE,W
0544:  BNZ   0534
....................    sprintf(comandoSET_NAME, "#SETNA"); 
0546:  CLRF   x88
0548:  MOVLW  79
054A:  MOVWF  x87
054C:  CLRF   xCE
054E:  MOVF   xCE,W
0550:  RCALL  00EC
0552:  INCF   xCE,F
0554:  MOVWF  00
0556:  MOVWF  xCF
0558:  RCALL  050C
055A:  MOVLW  06
055C:  SUBWF  xCE,W
055E:  BNZ   054E
....................    sprintf(comandoREMOTO, "#CREMO"); 
0560:  CLRF   x88
0562:  MOVLW  80
0564:  MOVWF  x87
0566:  CLRF   xCE
0568:  MOVF   xCE,W
056A:  RCALL  010E
056C:  INCF   xCE,F
056E:  MOVWF  00
0570:  MOVWF  xCF
0572:  RCALL  050C
0574:  MOVLW  06
0576:  SUBWF  xCE,W
0578:  BNZ   0568
.................... } 
057A:  GOTO   1BC6 (RETURN)
....................  
.................... /** 
....................  * Função para limpar o buffer de recepção serial (resposta_zigbee) 
....................  *  
....................  */ 
.................... void limpar_buffer(){  //TESTADO 
....................    int contador; 
....................    for(contador = 0; contador < MAX_BUFFER; contador++) 
057E:  CLRF   xCE
0580:  MOVF   xCE,W
0582:  SUBLW  31
0584:  BNC   059A
....................    { 
....................       buffer_resposta_zigbee[contador] = 0; 
0586:  CLRF   03
0588:  MOVF   xCE,W
058A:  ADDLW  20
058C:  MOVWF  FE9
058E:  MOVLW  00
0590:  ADDWFC 03,W
0592:  MOVWF  FEA
0594:  CLRF   FEF
....................    } 
0596:  INCF   xCE,F
0598:  BRA    0580
....................    contador_leitura = 0; 
059A:  CLRF   x71
....................    contador_escrita = 0; 
059C:  CLRF   x70
.................... } 
059E:  GOTO   1BCA (RETURN)
....................  
.................... /** 
....................  * Função Restore Defaults 
....................  * Restaura os parâmetros do módulo para as cofigurações de fábrica. Não reseta o parâmetro ID. 
....................  *  
....................  */ 
.................... void zigbee_restoreDefault()  //TESTADO 
.................... { 
....................    printf("AT RE"); //Envia o comando de reset 
....................    putc(0x0d); //CR     
.................... } 
....................  
.................... /** 
....................  * Função Software Reset 
....................  * Reseta o módulo. O módulo responde com um "OK" e realiza o reset por volta de 2 segundos depois. A camada de rede também pode ser resetada em alguns casos 
....................  *  
....................  */ 
.................... void zigbee_softwareReset()  //TESTADO 
.................... { 
....................    printf("AT FR"); 
....................    putc(0x0d);     
.................... } 
....................  
.................... /** 
....................  * Função Network Reset 
....................  * Reseta a camada de rede de um ou mais nós dentro de uma PAN (Personal Area Network). O módulo responde imediantamente com um "OK" ou "ERROR". 
....................  * Com o reset da camada de rede todos as configurações de rede e informações de roteamento são perdidas. 
....................  * Se parametro = "0" - O reset na camada de rede acontece apenas no módulo que está executando a função 
....................  *    parametro = "1" - Envia uma transmissão broadcast para resetar os parametros da camada de rede em todos os nós da PAN. 
....................  */ 
.................... void zigbee_NetworkReset(char *parametro)  //TESTADO 
.................... { 
....................    printf("AT NR %s", parametro); 
....................    putc(0x0d); 
.................... } 
....................  
.................... /** 
....................  * Função Write 
....................  * Escreve os parametros em uma memória não volátil (depois de um reset os parametros continuam os memsmos).  
....................  * Este comando responde com um "OK\r" 
....................  *  
....................  */ 
.................... void zigbee_Write()  //TESTADO 
.................... { 
....................    printf("AT WR"); 
*
194A:  CLRF   xCE
194C:  MOVF   xCE,W
194E:  CALL   0130
1952:  INCF   xCE,F
1954:  MOVWF  00
1956:  MOVF   00,W
1958:  BTFSS  F9E.4
195A:  BRA    1958
195C:  MOVWF  FAD
195E:  MOVLW  05
1960:  SUBWF  xCE,W
1962:  BNZ   194C
....................    putc(0x0d); 
1964:  MOVLW  0D
1966:  BTFSS  F9E.4
1968:  BRA    1966
196A:  MOVWF  FAD
.................... } 
196C:  GOTO   1A70 (RETURN)
....................  
.................... /** 
....................  * Função para ler os 32 bits mais altos do endereço de destino 
....................  * Este comando responde com os 32 bits mais altos do endereço de destino 
....................  *  
....................  */ 
.................... void zigbee_getDestinationAddressHigh()  //TESTADO 
.................... { 
....................    printf("AT DH"); 
....................    putc(0x0d); 
.................... } 
....................  
.................... /** 
....................  * Função para setar os 32 bits mais altos do endereço de destino 
....................  * Este comando responde com "OK" ou "ERROR". 
....................  *  
....................  */ 
.................... void zigbee_setDestinationAddressHigh(char* enderecoAlto)  //TESTADO 
.................... { 
....................    printf("AT DH %s", enderecoAlto); 
....................    putc(0x0d); 
.................... } 
....................  
.................... /** 
....................  * Função para ler os 32 bits mais baixos do endereço de destino 
....................  * Este comando responde com os 32 bits mais baixos do endereço de destino 
....................  *  
....................  */ 
.................... void zigbee_getDestinationAddressLow()  //TESTADO 
.................... { 
....................    printf("AT DL"); 
....................    putc(0x0d); 
.................... } 
....................  
.................... /** 
....................  * Função para setar os 32 bits mais baixos do endereço de destino 
....................  * Este comando responde com "OK" ou "ERROR". 
....................  *  
....................  */ 
.................... void zigbee_setDestinationAddressLow(char* enderecoBaixo)  //TESTADO 
.................... { 
....................    printf("AT DL %s", enderecoBaixo); 
....................    putc(0x0d); 
.................... } 
....................  
.................... /** 
....................  * Função ler o endereço de rede de 16-bits 
....................  * Este comando responde com o endereço do módulo 
....................  */ 
.................... void zigbee_MY() 
.................... { 
....................    printf("AT MY"); 
....................    putc(0x0d); 
.................... } 
....................  
.................... /** 
....................  * Função que retorna o endereço de rede de 16-bits do pai do nó. 
....................  * Este comando responde com o endereço do módulo pai 
....................  */ 
.................... void zigbee_MP() 
.................... { 
....................    printf("AT MP"); 
....................    putc(0x0d); 
.................... } 
....................  
.................... /** 
....................  * Função que retorna a parte alta (32bits) do identificador único do módulo 
....................  * 
....................  */ 
.................... void zigbee_SerialNumberHigh(){ 
....................    printf("AT SH"); 
*
0B30:  CLRF   xCE
0B32:  MOVF   xCE,W
0B34:  CALL   0150
0B38:  INCF   xCE,F
0B3A:  MOVWF  00
0B3C:  MOVF   00,W
0B3E:  BTFSS  F9E.4
0B40:  BRA    0B3E
0B42:  MOVWF  FAD
0B44:  MOVLW  05
0B46:  SUBWF  xCE,W
0B48:  BNZ   0B32
....................    putc(0x0d); 
0B4A:  MOVLW  0D
0B4C:  BTFSS  F9E.4
0B4E:  BRA    0B4C
0B50:  MOVWF  FAD
.................... } 
0B52:  GOTO   1C68 (RETURN)
....................  
.................... /** 
....................  * Função que retorna a parte baixa (32bits) do identificador único do módulo 
....................  * 
....................  */ 
.................... void zigbee_SerialNumberLow(){ 
....................    printf("AT SL"); 
0B56:  CLRF   xCE
0B58:  MOVF   xCE,W
0B5A:  CALL   0170
0B5E:  INCF   xCE,F
0B60:  MOVWF  00
0B62:  MOVF   00,W
0B64:  BTFSS  F9E.4
0B66:  BRA    0B64
0B68:  MOVWF  FAD
0B6A:  MOVLW  05
0B6C:  SUBWF  xCE,W
0B6E:  BNZ   0B58
....................    putc(0x0d); 
0B70:  MOVLW  0D
0B72:  BTFSS  F9E.4
0B74:  BRA    0B72
0B76:  MOVWF  FAD
.................... } 
0B78:  GOTO   1C94 (RETURN)
....................  
.................... /** 
....................  * Função que retorna a parte baixa (32bits) do identificador único do módulo 
....................  * 
....................  */ 
.................... void zigbee_EnableEncryption(){ 
....................    printf("AT EE 1"); 
....................    putc(0x0d); 
.................... } 
....................  
.................... /** 
....................  * Função que retorna a parte baixa (32bits) do identificador único do módulo 
....................  * 
....................  */ 
.................... void zigbee_setKY(int8 *key){ 
....................    printf("AT KY %s", key); 
....................    putc(0x0d); 
.................... } 
....................  
.................... /** 
....................  * Função para armazenar uma string identificadora do nó. O nome apenas pode conter caracteres ASCII imprimíveis.  
....................  * O tamanho máximo do nome é de 20Bytes. 
....................  *  
....................  */ 
.................... void zigbee_NodeIdentifier(char *nome){ //TESTADO 
....................    printf("AT NI %s", nome); 
*
1906:  CLRF   xD0
1908:  MOVF   xD0,W
190A:  CALL   0190
190E:  INCF   xD0,F
1910:  MOVWF  00
1912:  MOVF   00,W
1914:  BTFSS  F9E.4
1916:  BRA    1914
1918:  MOVWF  FAD
191A:  MOVLW  06
191C:  SUBWF  xD0,W
191E:  BNZ   1908
1920:  MOVFF  CF,FEA
1924:  MOVFF  CE,FE9
1928:  MOVLW  00
192A:  IORWF  FEF,W
192C:  BZ    193E
192E:  MOVF   FEF,W
1930:  BTFSS  F9E.4
1932:  BRA    1930
1934:  MOVWF  FAD
1936:  INCF   FE9,F
1938:  BTFSC  FD8.2
193A:  INCF   FEA,F
193C:  BRA    1928
....................    putc(0x0d); //CR 
193E:  MOVLW  0D
1940:  BTFSS  F9E.4
1942:  BRA    1940
1944:  MOVWF  FAD
.................... } 
1946:  GOTO   19B2 (RETURN)
....................  
.................... /** 
....................  * Função para ler o canal que o módulo está operando. Se o módulo não estiver associado em nenhuma rede o retorno desta função é "0" (zero). 
....................  *  
....................  */ 
.................... void zigbee_operatingChanel(){ //TESTADO 
....................    printf("AT CH"); 
....................    putc(0x0d); //CR 
.................... } 
....................  
.................... /** 
....................  * Função para setar o endereço PAN. Quando o módulo iniciar ele vai procurar uma PAN com o endereço setado para se associar. 
....................  * Se pan = 0xFFFF -> o módulo entra em qualquer PAN. 
....................  * Mudanças nesse parâmetro devem ser salvas através da função Write. 
....................  *  
....................  */ 
.................... void zigbee_setPANID(char *pan){ //TESTADO 
....................    printf("AT ID %s", pan); 
....................    putc(0x0d); //CR 
.................... } 
....................  
.................... /** 
....................  * Função para ler o endereço PAN. Quando o módulo iniciar ele vai procurar uma PAN com o endereço setado para se associar. 
....................  * Se pan = 0xFFFF -> o módulo entra em qualquer PAN. 
....................  * Mudanças nesse parâmetro devem ser salvas através da função Write. 
....................  *  
....................  */ 
.................... void zigbee_getPANID(){ //TESTADO 
....................    printf("AT ID"); 
....................    putc(0x0d); //CR 
.................... } 
....................  
.................... /** 
....................  * Função para setar o Node Discovery Timeout.  
....................  * Seta a quantidade de tempo que o nó vai gastar descobrindo outros nós quando o comando DN (ver mais a frente). 
....................  * time = de 0x20 - 0xFF [x 100msec] 
....................  */ 
.................... void zigbee_setNT(char *time){ //TESTADO 
....................    printf("AT NT %s", time); 
....................    putc(0x0d); //CR 
.................... } 
....................  
.................... /** 
....................  * Função para ler o Node Discovery Timeout.  
....................  * Seta a quantidade de tempo que o nó vai gastar descobrindo outros nós quando o comando DN (ver mais a frente). 
....................  */ 
.................... void zigbee_getNT(){ //TESTADO 
....................    printf("AT NT"); 
....................    putc(0x0d); //CR 
.................... } 
....................  
.................... /** 
....................  * Função Destination Node - Resolve um nome em um endereço físico.  
....................  * No modo de comandos AT, quando o comando é realizado, os parâmetros de Destino (tanto a parte alta quanto a parte baixa - SH e SL) 
....................  * recebem o endereço do nó cujo nome é igual ao parametro nomeDestino. 
....................  */ 
.................... void zigbee_destinationNode(char *nomeDestino){ //TESTADO 
....................    printf("AT DN %s", nomeDestino); 
*
0C50:  CLRF   xD1
0C52:  MOVF   xD1,W
0C54:  CALL   01B4
0C58:  INCF   xD1,F
0C5A:  MOVWF  00
0C5C:  MOVF   00,W
0C5E:  BTFSS  F9E.4
0C60:  BRA    0C5E
0C62:  MOVWF  FAD
0C64:  MOVLW  06
0C66:  SUBWF  xD1,W
0C68:  BNZ   0C52
0C6A:  MOVFF  D0,FEA
0C6E:  MOVFF  CF,FE9
0C72:  MOVLW  00
0C74:  IORWF  FEF,W
0C76:  BZ    0C88
0C78:  MOVF   FEF,W
0C7A:  BTFSS  F9E.4
0C7C:  BRA    0C7A
0C7E:  MOVWF  FAD
0C80:  INCF   FE9,F
0C82:  BTFSC  FD8.2
0C84:  INCF   FEA,F
0C86:  BRA    0C72
....................    putc(0x0d); //CR 
0C88:  MOVLW  0D
0C8A:  BTFSS  F9E.4
0C8C:  BRA    0C8A
0C8E:  MOVWF  FAD
.................... } 
0C90:  GOTO   0CCC (RETURN)
....................  
.................... /** 
....................  * Função para enviar uma string 
....................  * O módulo deve estar no modo bypass (conexão estabelecida) 
....................  * Obs.: A string não deve conter a sequencia de caracteres AT 
....................  */ 
.................... void enviar_string(char* string){ //TESTADO 
....................    putc(0x23); //# 
....................    printf("%s", string); 
....................    putc(0x24); //$ 
.................... } 
....................  
.................... /** 
....................  * Função para enviar um inteiro 
....................  * O módulo deve estar no modo bypass (conexão estabelecida) 
....................  */ 
.................... void enviar_inteiro(int numero){ //TESTADO 
....................    putc(0x23); //# 
....................    putc(numero); 
....................    putc(0x24); //$ 
.................... } 
....................  
.................... /** 
....................  * Função para enviar um caractere 
....................  * O módulo deve estar no modo bypass (conexão estabelecida) 
....................  */ 
.................... void enviar_char(char caractere){ //TESTADO 
....................    putc(0x23); //# 
....................    printf("%c", caractere); 
....................    putc(0x24); //$ 
.................... } 
....................  
.................... /** 
....................  * Função que compara se o comando AT-ZV que está no array resposta é igual ao argumento *string. 
....................  * o argumento caracteres é o tamanho (quantidade de caracteres) de string. 
....................  * A função retorna 1 se a resposta for igual e 0 se for diferente. 
....................  *EX.: sprintf(auxiliar, "InqPending"); 
....................  *     if(comparar_resposta(auxiliar, 10)){ //Verifica se a resposta obtida é "InqPending", lembrando que a resposta completa é AT-ZV InqPending 
....................   
.................... int comparar_resposta(int *string, int caracteres){ 
....................    int i; 
....................    for(i = 0; i < caracteres; i++){ 
....................       if(resposta[i+6] != string[i]){ 
....................          return 0; 
....................       } 
....................    } 
....................    return 1; 
.................... } 
.................... */ 
.................... void enviar_pacote_Leitura(int8* enderecoH, int8* enderecoL, int8 canalLido, int8* valorLido){ //TESTADO 
....................    printf( "#READV*%s*%s*%d*%s\r",enderecoH,enderecoL,(canalLido+1), valorLido ); 
*
1762:  MOVLW  01
1764:  ADDWF  xD3,W
1766:  MOVWF  xD6
1768:  CLRF   xD7
176A:  MOVF   xD7,W
176C:  CALL   01D8
1770:  INCF   xD7,F
1772:  MOVWF  00
1774:  MOVF   00,W
1776:  BTFSS  F9E.4
1778:  BRA    1776
177A:  MOVWF  FAD
177C:  MOVLW  07
177E:  SUBWF  xD7,W
1780:  BNZ   176A
1782:  MOVFF  D0,FEA
1786:  MOVFF  CF,FE9
178A:  MOVLW  00
178C:  IORWF  FEF,W
178E:  BZ    17A0
1790:  MOVF   FEF,W
1792:  BTFSS  F9E.4
1794:  BRA    1792
1796:  MOVWF  FAD
1798:  INCF   FE9,F
179A:  BTFSC  FD8.2
179C:  INCF   FEA,F
179E:  BRA    178A
17A0:  MOVLW  2A
17A2:  BTFSS  F9E.4
17A4:  BRA    17A2
17A6:  MOVWF  FAD
17A8:  MOVFF  D2,FEA
17AC:  MOVFF  D1,FE9
17B0:  MOVLW  00
17B2:  IORWF  FEF,W
17B4:  BZ    17C6
17B6:  MOVF   FEF,W
17B8:  BTFSS  F9E.4
17BA:  BRA    17B8
17BC:  MOVWF  FAD
17BE:  INCF   FE9,F
17C0:  BTFSC  FD8.2
17C2:  INCF   FEA,F
17C4:  BRA    17B0
17C6:  MOVLW  2A
17C8:  BTFSS  F9E.4
17CA:  BRA    17C8
17CC:  MOVWF  FAD
17CE:  MOVFF  D6,DC
17D2:  MOVLW  1F
17D4:  MOVWF  xDD
17D6:  BRA    166C
17D8:  MOVLW  2A
17DA:  BTFSS  F9E.4
17DC:  BRA    17DA
17DE:  MOVWF  FAD
17E0:  MOVFF  D5,FEA
17E4:  MOVFF  D4,FE9
17E8:  MOVLW  00
17EA:  IORWF  FEF,W
17EC:  BZ    17FE
17EE:  MOVF   FEF,W
17F0:  BTFSS  F9E.4
17F2:  BRA    17F0
17F4:  MOVWF  FAD
17F6:  INCF   FE9,F
17F8:  BTFSC  FD8.2
17FA:  INCF   FEA,F
17FC:  BRA    17E8
17FE:  MOVLW  0D
1800:  BTFSS  F9E.4
1802:  BRA    1800
1804:  MOVWF  FAD
....................    //putc(0x0d); //CR 
.................... } 
1806:  GOTO   1896 (RETURN)
....................  
.................... void irParaModoComando() 
.................... { 
....................    delay_ms(1000); 
*
0848:  MOVLW  04
084A:  MOVWF  xDD
084C:  MOVLW  FA
084E:  MOVWF  xE8
0850:  RCALL  05A2
0852:  DECFSZ xDD,F
0854:  BRA    084C
....................    printf( "+++" ); 
0856:  MOVLW  2B
0858:  BTFSS  F9E.4
085A:  BRA    0858
085C:  MOVWF  FAD
085E:  MOVLW  2B
0860:  BTFSS  F9E.4
0862:  BRA    0860
0864:  MOVWF  FAD
0866:  MOVLW  2B
0868:  BTFSS  F9E.4
086A:  BRA    0868
086C:  MOVWF  FAD
....................    delay_ms(1000); 
086E:  MOVLW  04
0870:  MOVWF  xDD
0872:  MOVLW  FA
0874:  MOVWF  xE8
0876:  RCALL  05A2
0878:  DECFSZ xDD,F
087A:  BRA    0872
.................... } 
087C:  GOTO   0AB8 (RETURN)
....................  
.................... void irParaModoTransparente() 
.................... { 
....................    printf("ATCN\r"); 
*
0B7C:  CLRF   xDD
0B7E:  MOVF   xDD,W
0B80:  CALL   0206
0B84:  INCF   xDD,F
0B86:  MOVWF  00
0B88:  MOVF   00,W
0B8A:  BTFSS  F9E.4
0B8C:  BRA    0B8A
0B8E:  MOVWF  FAD
0B90:  MOVLW  05
0B92:  SUBWF  xDD,W
0B94:  BNZ   0B7E
....................    //delay_ms(100); 
.................... } 
0B96:  GOTO   0BCA (RETURN)
....................  
.................... void esperaPacote() 
.................... { 
....................    int8 i = 0; 
*
09F8:  CLRF   xDD
....................    while(chegouPacote() != 1 && i < 200) 
....................    { 
09FA:  RCALL  090E
09FC:  DECFSZ 01,W
09FE:  BRA    0A02
0A00:  BRA    0A12
0A02:  MOVF   xDD,W
0A04:  SUBLW  C7
0A06:  BNC   0A12
....................       ; 
....................       delay_ms(100); 
0A08:  MOVLW  64
0A0A:  MOVWF  xE8
0A0C:  RCALL  05A2
....................       i++; 
0A0E:  INCF   xDD,F
....................    } 
0A10:  BRA    09FA
.................... } 
0A12:  RETLW  00
....................  
....................  
.................... void tratarPacote(Pacote *pacoteRecebidoStruct) 
.................... { 
....................      char pacoteRecebidoAux[10]; 
....................      int i; 
....................      int indexInformacao = 0; 
*
1206:  CLRF   xDB
....................       
....................      for(i = 0; i < 10 ; i++) 
1208:  CLRF   xDA
120A:  MOVF   xDA,W
120C:  SUBLW  09
120E:  BNC   1224
....................      { 
....................          pacoteRecebidoAux[i] = 0; 
1210:  CLRF   03
1212:  MOVF   xDA,W
1214:  ADDLW  D0
1216:  MOVWF  FE9
1218:  MOVLW  00
121A:  ADDWFC 03,W
121C:  MOVWF  FEA
121E:  CLRF   FEF
....................      } 
1220:  INCF   xDA,F
1222:  BRA    120A
....................       
....................       
....................      for(i = 0; i < 10 ; i++) 
1224:  CLRF   xDA
1226:  MOVF   xDA,W
1228:  SUBLW  09
122A:  BNC   12AA
....................      { 
....................          if (pacoteRecebido[i] == 0) 
122C:  CLRF   03
122E:  MOVF   xDA,W
1230:  ADDLW  52
1232:  MOVWF  FE9
1234:  MOVLW  00
1236:  ADDWFC 03,W
1238:  MOVWF  FEA
123A:  MOVF   FEF,F
123C:  BNZ   124E
....................          { 
....................             pacoteRecebidoStruct->tipoPacote = PACOTE_NAO_IDENTIFICADO; 
123E:  MOVFF  CE,FE9
1242:  MOVFF  CF,FEA
1246:  MOVLW  03
1248:  MOVWF  FEF
....................             return; 
124A:  BRA    138A
....................          } 
....................          else if (pacoteRecebido[i] == '*') 
124C:  BRA    12A6
124E:  CLRF   03
1250:  MOVF   xDA,W
1252:  ADDLW  52
1254:  MOVWF  FE9
1256:  MOVLW  00
1258:  ADDWFC 03,W
125A:  MOVWF  FEA
125C:  MOVF   FEF,W
125E:  SUBLW  2A
1260:  BNZ   1278
....................          { 
....................             pacoteRecebidoAux[i] = '\0'; 
1262:  CLRF   03
1264:  MOVF   xDA,W
1266:  ADDLW  D0
1268:  MOVWF  FE9
126A:  MOVLW  00
126C:  ADDWFC 03,W
126E:  MOVWF  FEA
1270:  CLRF   FEF
....................             i++; 
1272:  INCF   xDA,F
....................             break; 
1274:  BRA    12AA
....................          }else 
1276:  BRA    12A6
....................          { 
....................             pacoteRecebidoAux[i] = pacoteRecebido[i]; 
1278:  CLRF   03
127A:  MOVF   xDA,W
127C:  ADDLW  D0
127E:  MOVWF  01
1280:  MOVLW  00
1282:  ADDWFC 03,F
1284:  MOVFF  03,DD
1288:  CLRF   03
128A:  MOVF   xDA,W
128C:  ADDLW  52
128E:  MOVWF  FE9
1290:  MOVLW  00
1292:  ADDWFC 03,W
1294:  MOVWF  FEA
1296:  MOVFF  FEF,DE
129A:  MOVFF  DD,FEA
129E:  MOVFF  01,FE9
12A2:  MOVFF  DE,FEF
....................          } 
....................      } 
12A6:  INCF   xDA,F
12A8:  BRA    1226
....................       
....................      if(strcmp(pacoteRecebidoAux, comandoREADR) == 0) 
12AA:  CLRF   xDE
12AC:  MOVLW  D0
12AE:  MOVWF  xDD
12B0:  CLRF   xE0
12B2:  MOVLW  72
12B4:  MOVWF  xDF
12B6:  CALL   0A14
12BA:  MOVF   01,F
12BC:  BNZ   12CA
....................      { 
....................          pacoteRecebidoStruct->tipoPacote = READR; 
12BE:  MOVFF  CE,FE9
12C2:  MOVFF  CF,FEA
12C6:  CLRF   FEF
....................      }else if(strcmp(pacoteRecebidoAux, comandoSET_NAME) == 0) 
12C8:  BRA    131C
12CA:  CLRF   xDE
12CC:  MOVLW  D0
12CE:  MOVWF  xDD
12D0:  CLRF   xE0
12D2:  MOVLW  79
12D4:  MOVWF  xDF
12D6:  CALL   0A14
12DA:  MOVF   01,F
12DC:  BNZ   12EC
....................      { 
....................          pacoteRecebidoStruct->tipoPacote = SET_NAME; 
12DE:  MOVFF  CE,FE9
12E2:  MOVFF  CF,FEA
12E6:  MOVLW  01
12E8:  MOVWF  FEF
....................      }else if(strcmp(pacoteRecebidoAux, comandoREMOTO) == 0) 
12EA:  BRA    131C
12EC:  CLRF   xDE
12EE:  MOVLW  D0
12F0:  MOVWF  xDD
12F2:  CLRF   xE0
12F4:  MOVLW  80
12F6:  MOVWF  xDF
12F8:  CALL   0A14
12FC:  MOVF   01,F
12FE:  BNZ   130E
....................      { 
....................          pacoteRecebidoStruct->tipoPacote = COMANDO_REMOTO; 
1300:  MOVFF  CE,FE9
1304:  MOVFF  CF,FEA
1308:  MOVLW  02
130A:  MOVWF  FEF
....................      }else 
130C:  BRA    131C
....................      { 
....................          pacoteRecebidoStruct->tipoPacote = PACOTE_NAO_IDENTIFICADO; 
130E:  MOVFF  CE,FE9
1312:  MOVFF  CF,FEA
1316:  MOVLW  03
1318:  MOVWF  FEF
....................          return; 
131A:  BRA    138A
....................      } 
....................       
....................      
....................      for(; i < MAX_PACOTE; i++) 
131C:  MOVF   xDA,W
131E:  SUBLW  1D
1320:  BNC   138A
....................      { 
....................          if (pacoteRecebido[i] == '\r' || pacoteRecebido[i] == 0) 
1322:  CLRF   03
1324:  MOVF   xDA,W
1326:  ADDLW  52
1328:  MOVWF  FE9
132A:  MOVLW  00
132C:  ADDWFC 03,W
132E:  MOVWF  FEA
1330:  MOVF   FEF,W
1332:  SUBLW  0D
1334:  BZ    1348
1336:  CLRF   03
1338:  MOVF   xDA,W
133A:  ADDLW  52
133C:  MOVWF  FE9
133E:  MOVLW  00
1340:  ADDWFC 03,W
1342:  MOVWF  FEA
1344:  MOVF   FEF,F
1346:  BNZ   134C
....................          { 
....................             return; 
1348:  BRA    138A
....................          }else 
134A:  BRA    1386
....................          { 
....................             pacoteRecebidoStruct->informacao[indexInformacao] =  pacoteRecebido[i]; 
134C:  CLRF   03
134E:  MOVF   xDB,W
1350:  ADDLW  01
1352:  MOVWF  01
1354:  MOVLW  00
1356:  ADDWFC 03,F
1358:  MOVF   01,W
135A:  ADDWF  xCE,W
135C:  MOVWF  01
135E:  MOVF   xCF,W
1360:  ADDWFC 03,F
1362:  MOVFF  03,DD
1366:  CLRF   03
1368:  MOVF   xDA,W
136A:  ADDLW  52
136C:  MOVWF  FE9
136E:  MOVLW  00
1370:  ADDWFC 03,W
1372:  MOVWF  FEA
1374:  MOVFF  FEF,DE
1378:  MOVFF  DD,FEA
137C:  MOVFF  01,FE9
1380:  MOVFF  DE,FEF
....................             indexInformacao++; 
1384:  INCF   xDB,F
....................          } 
....................      } 
1386:  INCF   xDA,F
1388:  BRA    131C
.................... } 
138A:  GOTO   1E20 (RETURN)
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float32 atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................  #cdebug5      
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr) { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define TAXA_ATUALIZACAO_DESTINO 100 
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... //VARIÁVEIS GLOBAIS// 
.................... ////////////////////////////////////////////////////////////////// 
.................... int8 enderecoH[10]; 
.................... int8 enderecoL[10]; 
.................... int8 stringOK[3]; 
.................... int8 stringDestinationNodeName[5]; 
.................... int8 keyPassword[10]; 
.................... int8 quantidadePacotesEnviados; 
.................... Pacote pacoteStruct; 
.................... int32 valorLeituraAD; 
.................... int8 valorStringLeituraAD[10]; 
.................... ////////////////////////////////////////////////////////////////// 
.................... //FIM DAS VARIÁVEIS GLOBAIS// 
.................... ////////////////////////////////////////////////////////////////// 
.................... //---------------------------------------------------------------------- 
.................... ////////////////////////////////////////////////////////////////// 
.................... //CÓDIGO DE INTERRUPÇÃO SERIAL// 
.................... ////////////////////////////////////////////////////////////////// 
.................... #int_rda 
.................... void reception () 
.................... { 
....................    interrupcao_serial(); //Na interrupção da serial basta chamar a função da Biblioteca ZigBee 
*
0504:  BRA    04CC
.................... } 
.................... ////////////////////////////////////////////////////////////////// 
.................... //FIM DO CÓDIGO DE INTERRUPÇÃO SERIAL// 
.................... ////////////////////////////////////////////////////////////////// 
.................... //---------------------------------------------------------------------- 
.................... ////////////////////////////////////////////////////////////////// 
.................... //FUNÇÕES UTILIZADAS PELO MAIN// 
.................... ////////////////////////////////////////////////////////////////// 
0506:  BCF    F9E.5
0508:  GOTO   0058
.................... void modoComando() 
.................... { 
....................    do 
....................    { 
....................       clearLCD(); 
*
0A88:  RCALL  0842
....................       lcd_gotoxy(1,1); 
0A8A:  MOVLW  01
0A8C:  MOVWF  xE0
0A8E:  MOVWF  xE1
0A90:  RCALL  067E
....................       printf(lcd_putc,"Modo comando..."); 
0A92:  CLRF   xDD
0A94:  MOVF   xDD,W
0A96:  CALL   0226
0A9A:  INCF   xDD,F
0A9C:  MOVWF  00
0A9E:  MOVWF  xDF
0AA0:  RCALL  07BE
0AA2:  MOVLW  0F
0AA4:  SUBWF  xDD,W
0AA6:  BNZ   0A94
....................       delay_ms(1000); 
0AA8:  MOVLW  04
0AAA:  MOVWF  xDD
0AAC:  MOVLW  FA
0AAE:  MOVWF  xE8
0AB0:  RCALL  05A2
0AB2:  DECFSZ xDD,F
0AB4:  BRA    0AAC
....................        
....................       irParaModoComando(); 
0AB6:  BRA    0848
....................       esperaPacote(); 
0AB8:  RCALL  09F8
....................        
....................       clearLCD(); 
0ABA:  RCALL  0842
....................       lcd_gotoxy(1,1); 
0ABC:  MOVLW  01
0ABE:  MOVWF  xE0
0AC0:  MOVWF  xE1
0AC2:  RCALL  067E
....................       printf(lcd_putc,"Resp Recebida"); 
0AC4:  CLRF   xDD
0AC6:  MOVF   xDD,W
0AC8:  CALL   0250
0ACC:  INCF   xDD,F
0ACE:  MOVWF  00
0AD0:  MOVWF  xDF
0AD2:  RCALL  07BE
0AD4:  MOVLW  0D
0AD6:  SUBWF  xDD,W
0AD8:  BNZ   0AC6
....................       lcd_gotoxy(1,2); 
0ADA:  MOVLW  01
0ADC:  MOVWF  xE0
0ADE:  MOVLW  02
0AE0:  MOVWF  xE1
0AE2:  RCALL  067E
....................       printf(lcd_putc,"%s", pacoteRecebido); 
0AE4:  CLRF   FEA
0AE6:  MOVLW  52
0AE8:  MOVWF  FE9
0AEA:  MOVLW  00
0AEC:  IORWF  FEF,W
0AEE:  BZ    0B0E
0AF0:  MOVFF  FEA,DE
0AF4:  MOVFF  FE9,DD
0AF8:  MOVFF  FEF,DF
0AFC:  RCALL  07BE
0AFE:  MOVFF  DE,FEA
0B02:  MOVFF  DD,FE9
0B06:  INCF   FE9,F
0B08:  BTFSC  FD8.2
0B0A:  INCF   FEA,F
0B0C:  BRA    0AEA
....................       delay_ms(1000); 
0B0E:  MOVLW  04
0B10:  MOVWF  xDD
0B12:  MOVLW  FA
0B14:  MOVWF  xE8
0B16:  RCALL  05A2
0B18:  DECFSZ xDD,F
0B1A:  BRA    0B12
....................    }while ( strcmp( pacoteRecebido, stringOK) != 0 ); 
0B1C:  CLRF   xDE
0B1E:  MOVLW  52
0B20:  MOVWF  xDD
0B22:  CLRF   xE0
0B24:  MOVLW  9D
0B26:  MOVWF  xDF
0B28:  RCALL  0A14
0B2A:  MOVF   01,F
0B2C:  BNZ   0A88
.................... } 
0B2E:  RETLW  00
....................  
.................... void modoTransparente() 
.................... { 
....................    clearLCD(); 
*
0B9A:  RCALL  0842
....................    lcd_gotoxy(1,1); 
0B9C:  MOVLW  01
0B9E:  MOVWF  xE0
0BA0:  MOVWF  xE1
0BA2:  RCALL  067E
....................    printf(lcd_putc,"Modo transparente..."); 
0BA4:  CLRF   xDD
0BA6:  MOVF   xDD,W
0BA8:  CALL   0278
0BAC:  INCF   xDD,F
0BAE:  MOVWF  00
0BB0:  MOVWF  xDF
0BB2:  RCALL  07BE
0BB4:  MOVLW  14
0BB6:  SUBWF  xDD,W
0BB8:  BNZ   0BA6
....................    delay_ms(1000); 
0BBA:  MOVLW  04
0BBC:  MOVWF  xDD
0BBE:  MOVLW  FA
0BC0:  MOVWF  xE8
0BC2:  RCALL  05A2
0BC4:  DECFSZ xDD,F
0BC6:  BRA    0BBE
....................     
....................    irParaModoTransparente(); 
0BC8:  BRA    0B7C
....................    esperaPacote(); 
0BCA:  RCALL  09F8
....................     
....................    clearLCD(); 
0BCC:  RCALL  0842
....................    lcd_gotoxy(1,1); 
0BCE:  MOVLW  01
0BD0:  MOVWF  xE0
0BD2:  MOVWF  xE1
0BD4:  RCALL  067E
....................    printf(lcd_putc,"Resp Recebida"); 
0BD6:  CLRF   xDD
0BD8:  MOVF   xDD,W
0BDA:  CALL   0250
0BDE:  INCF   xDD,F
0BE0:  MOVWF  00
0BE2:  MOVWF  xDF
0BE4:  RCALL  07BE
0BE6:  MOVLW  0D
0BE8:  SUBWF  xDD,W
0BEA:  BNZ   0BD8
....................    lcd_gotoxy(1,2); 
0BEC:  MOVLW  01
0BEE:  MOVWF  xE0
0BF0:  MOVLW  02
0BF2:  MOVWF  xE1
0BF4:  RCALL  067E
....................    printf(lcd_putc,"%s", pacoteRecebido); 
0BF6:  CLRF   FEA
0BF8:  MOVLW  52
0BFA:  MOVWF  FE9
0BFC:  MOVLW  00
0BFE:  IORWF  FEF,W
0C00:  BZ    0C20
0C02:  MOVFF  FEA,DE
0C06:  MOVFF  FE9,DD
0C0A:  MOVFF  FEF,DF
0C0E:  RCALL  07BE
0C10:  MOVFF  DE,FEA
0C14:  MOVFF  DD,FE9
0C18:  INCF   FE9,F
0C1A:  BTFSC  FD8.2
0C1C:  INCF   FEA,F
0C1E:  BRA    0BFC
....................    delay_ms(1000); 
0C20:  MOVLW  04
0C22:  MOVWF  xDD
0C24:  MOVLW  FA
0C26:  MOVWF  xE8
0C28:  RCALL  05A2
0C2A:  DECFSZ xDD,F
0C2C:  BRA    0C24
....................    if ( strcmp( pacoteRecebido, stringOK) != 0 ) 
0C2E:  CLRF   xDE
0C30:  MOVLW  52
0C32:  MOVWF  xDD
0C34:  CLRF   xE0
0C36:  MOVLW  9D
0C38:  MOVWF  xDF
0C3A:  RCALL  0A14
0C3C:  MOVF   01,F
0C3E:  BZ    0C4E
....................    { 
....................       delay_ms(2000); //se nao recebeu resposta vai para modo transparente por delay 
0C40:  MOVLW  08
0C42:  MOVWF  xDD
0C44:  MOVLW  FA
0C46:  MOVWF  xE8
0C48:  RCALL  05A2
0C4A:  DECFSZ xDD,F
0C4C:  BRA    0C44
....................    } 
.................... } 
0C4E:  RETLW  00
.................... void setarDesstinoConcentrador() 
.................... { 
....................   modoComando(); 
*
0C94:  RCALL  0A88
....................    
....................   do 
....................   { 
....................      clearLCD(); 
0C96:  RCALL  0842
....................      lcd_gotoxy(1,1); 
0C98:  MOVLW  01
0C9A:  MOVWF  xE0
0C9C:  MOVWF  xE1
0C9E:  RCALL  067E
....................      printf(lcd_putc,"Setando Destino..."); 
0CA0:  CLRF   xCF
0CA2:  MOVF   xCF,W
0CA4:  CALL   02A8
0CA8:  INCF   xCF,F
0CAA:  MOVWF  00
0CAC:  MOVWF  xDF
0CAE:  RCALL  07BE
0CB0:  MOVLW  12
0CB2:  SUBWF  xCF,W
0CB4:  BNZ   0CA2
....................      delay_ms(1000); 
0CB6:  MOVLW  04
0CB8:  MOVWF  xCF
0CBA:  MOVLW  FA
0CBC:  MOVWF  xE8
0CBE:  RCALL  05A2
0CC0:  DECFSZ xCF,F
0CC2:  BRA    0CBA
....................       
....................      zigbee_destinationNode(stringDestinationNodeName); 
0CC4:  CLRF   xD0
0CC6:  MOVLW  A0
0CC8:  MOVWF  xCF
0CCA:  BRA    0C50
....................      esperaPacote(); 
0CCC:  RCALL  09F8
....................       
....................      clearLCD(); 
0CCE:  RCALL  0842
....................      lcd_gotoxy(1,1); 
0CD0:  MOVLW  01
0CD2:  MOVWF  xE0
0CD4:  MOVWF  xE1
0CD6:  RCALL  067E
....................      printf(lcd_putc,"Destino Setado..."); 
0CD8:  CLRF   xCF
0CDA:  MOVF   xCF,W
0CDC:  CALL   02D6
0CE0:  INCF   xCF,F
0CE2:  MOVWF  00
0CE4:  MOVWF  xDF
0CE6:  RCALL  07BE
0CE8:  MOVLW  11
0CEA:  SUBWF  xCF,W
0CEC:  BNZ   0CDA
....................      lcd_gotoxy(1,2); 
0CEE:  MOVLW  01
0CF0:  MOVWF  xE0
0CF2:  MOVLW  02
0CF4:  MOVWF  xE1
0CF6:  RCALL  067E
....................      printf(lcd_putc,"%s", pacoteRecebido); 
0CF8:  CLRF   FEA
0CFA:  MOVLW  52
0CFC:  MOVWF  FE9
0CFE:  MOVLW  00
0D00:  IORWF  FEF,W
0D02:  BZ    0D22
0D04:  MOVFF  FEA,D0
0D08:  MOVFF  FE9,CF
0D0C:  MOVFF  FEF,DF
0D10:  RCALL  07BE
0D12:  MOVFF  D0,FEA
0D16:  MOVFF  CF,FE9
0D1A:  INCF   FE9,F
0D1C:  BTFSC  FD8.2
0D1E:  INCF   FEA,F
0D20:  BRA    0CFE
....................      delay_ms(1000); 
0D22:  MOVLW  04
0D24:  MOVWF  xCF
0D26:  MOVLW  FA
0D28:  MOVWF  xE8
0D2A:  RCALL  05A2
0D2C:  DECFSZ xCF,F
0D2E:  BRA    0D26
....................       
....................   }while ( strcmp( pacoteRecebido, stringOK) != 0 ); 
0D30:  CLRF   xDE
0D32:  MOVLW  52
0D34:  MOVWF  xDD
0D36:  CLRF   xE0
0D38:  MOVLW  9D
0D3A:  MOVWF  xDF
0D3C:  RCALL  0A14
0D3E:  MOVF   01,F
0D40:  BNZ   0C96
....................    
.................... } 
0D42:  RETLW  00
....................  
.................... void enviarLeitura() 
.................... { 
....................    int8 canal; 
....................    canal = atoi(pacoteStruct.informacao); 
*
180A:  CLRF   xD0
180C:  MOVLW  B1
180E:  MOVWF  xCF
1810:  BRA    13DA
1812:  MOVFF  01,CE
....................    canal = canal-1; 
1816:  MOVLW  01
1818:  SUBWF  xCE,F
....................    ler_canal_AD_para_puint8( canal, valorStringLeituraAD ); 
181A:  MOVFF  CE,CF
181E:  CLRF   xD1
1820:  MOVLW  C4
1822:  MOVWF  xD0
1824:  RCALL  1056
....................    clearLCD(); 
1826:  CALL   0842
....................    lcd_gotoxy(1,1); 
182A:  MOVLW  01
182C:  MOVWF  xE0
182E:  MOVWF  xE1
1830:  CALL   067E
....................    printf(lcd_putc,"VOU ENVIAR %d...", canal); 
1834:  CLRF   xCF
1836:  MOVF   xCF,W
1838:  CALL   0302
183C:  INCF   xCF,F
183E:  MOVWF  00
1840:  MOVWF  xDF
1842:  CALL   07BE
1846:  MOVLW  0B
1848:  SUBWF  xCF,W
184A:  BNZ   1836
184C:  MOVFF  CE,D0
1850:  MOVLW  1F
1852:  MOVWF  xD1
1854:  BRA    1576
1856:  MOVLW  2E
1858:  MOVWF  xDF
185A:  CALL   07BE
185E:  MOVLW  2E
1860:  MOVWF  xDF
1862:  CALL   07BE
1866:  MOVLW  2E
1868:  MOVWF  xDF
186A:  CALL   07BE
....................    delay_ms(1000); 
186E:  MOVLW  04
1870:  MOVWF  xCF
1872:  MOVLW  FA
1874:  MOVWF  xE8
1876:  CALL   05A2
187A:  DECFSZ xCF,F
187C:  BRA    1872
....................     
....................    enviar_pacote_Leitura(enderecoH, enderecoL, canal, valorStringLeituraAD); 
187E:  CLRF   xD0
1880:  MOVLW  89
1882:  MOVWF  xCF
1884:  CLRF   xD2
1886:  MOVLW  93
1888:  MOVWF  xD1
188A:  MOVFF  CE,D3
188E:  CLRF   xD5
1890:  MOVLW  C4
1892:  MOVWF  xD4
1894:  BRA    1762
....................     
....................    clearLCD(); 
1896:  CALL   0842
....................    lcd_gotoxy(1,1); 
189A:  MOVLW  01
189C:  MOVWF  xE0
189E:  MOVWF  xE1
18A0:  CALL   067E
....................    printf(lcd_putc,"ENVIEI..."); 
18A4:  CLRF   xCF
18A6:  MOVF   xCF,W
18A8:  CALL   032E
18AC:  INCF   xCF,F
18AE:  MOVWF  00
18B0:  MOVWF  xDF
18B2:  CALL   07BE
18B6:  MOVLW  09
18B8:  SUBWF  xCF,W
18BA:  BNZ   18A6
....................    delay_ms(1000); 
18BC:  MOVLW  04
18BE:  MOVWF  xCF
18C0:  MOVLW  FA
18C2:  MOVWF  xE8
18C4:  CALL   05A2
18C8:  DECFSZ xCF,F
18CA:  BRA    18C0
....................     
....................    quantidadePacotesEnviados = (quantidadePacotesEnviados+1); 
18CC:  MOVLW  01
18CE:  ADDWF  xAF,F
....................    if(quantidadePacotesEnviados == TAXA_ATUALIZACAO_DESTINO) 
18D0:  MOVF   xAF,W
18D2:  SUBLW  64
18D4:  BNZ   18DC
....................    { 
....................       quantidadePacotesEnviados = 0; 
18D6:  CLRF   xAF
....................       setarDesstinoConcentrador(); 
18D8:  CALL   0C94
....................    } 
.................... } 
18DC:  RETLW  00
.................... void setarNomeDevice() 
.................... { 
....................    modoComando(); 
*
1970:  CALL   0A88
....................    do 
....................    { 
....................      clearLCD(); 
1974:  CALL   0842
....................      lcd_gotoxy(1,1); 
1978:  MOVLW  01
197A:  MOVWF  xE0
197C:  MOVWF  xE1
197E:  CALL   067E
....................      printf(lcd_putc,"Setando Nome..."); 
1982:  CLRF   xCE
1984:  MOVF   xCE,W
1986:  CALL   0352
198A:  INCF   xCE,F
198C:  MOVWF  00
198E:  MOVWF  xDF
1990:  CALL   07BE
1994:  MOVLW  0F
1996:  SUBWF  xCE,W
1998:  BNZ   1984
....................      delay_ms(1000); 
199A:  MOVLW  04
199C:  MOVWF  xCE
199E:  MOVLW  FA
19A0:  MOVWF  xE8
19A2:  CALL   05A2
19A6:  DECFSZ xCE,F
19A8:  BRA    199E
....................           
....................      zigbee_NodeIdentifier(pacoteStruct.informacao); 
19AA:  CLRF   xCF
19AC:  MOVLW  B1
19AE:  MOVWF  xCE
19B0:  BRA    1906
....................      esperaPacote(); 
19B2:  CALL   09F8
....................       
....................      clearLCD(); 
19B6:  CALL   0842
....................      lcd_gotoxy(1,1); 
19BA:  MOVLW  01
19BC:  MOVWF  xE0
19BE:  MOVWF  xE1
19C0:  CALL   067E
....................      printf(lcd_putc,"Nome Setado..."); 
19C4:  CLRF   xCE
19C6:  MOVF   xCE,W
19C8:  CALL   037C
19CC:  INCF   xCE,F
19CE:  MOVWF  00
19D0:  MOVWF  xDF
19D2:  CALL   07BE
19D6:  MOVLW  0E
19D8:  SUBWF  xCE,W
19DA:  BNZ   19C6
....................      lcd_gotoxy(1,2); 
19DC:  MOVLW  01
19DE:  MOVWF  xE0
19E0:  MOVLW  02
19E2:  MOVWF  xE1
19E4:  CALL   067E
....................      printf(lcd_putc,"%s", pacoteRecebido); 
19E8:  CLRF   FEA
19EA:  MOVLW  52
19EC:  MOVWF  FE9
19EE:  MOVLW  00
19F0:  IORWF  FEF,W
19F2:  BZ    1A14
19F4:  MOVFF  FEA,CF
19F8:  MOVFF  FE9,CE
19FC:  MOVFF  FEF,DF
1A00:  CALL   07BE
1A04:  MOVFF  CF,FEA
1A08:  MOVFF  CE,FE9
1A0C:  INCF   FE9,F
1A0E:  BTFSC  FD8.2
1A10:  INCF   FEA,F
1A12:  BRA    19EE
....................      delay_ms(1000); 
1A14:  MOVLW  04
1A16:  MOVWF  xCE
1A18:  MOVLW  FA
1A1A:  MOVWF  xE8
1A1C:  CALL   05A2
1A20:  DECFSZ xCE,F
1A22:  BRA    1A18
....................       
....................   }while ( strcmp( pacoteRecebido, stringOK) != 0 ); 
1A24:  CLRF   xDE
1A26:  MOVLW  52
1A28:  MOVWF  xDD
1A2A:  CLRF   xE0
1A2C:  MOVLW  9D
1A2E:  MOVWF  xDF
1A30:  CALL   0A14
1A34:  MOVF   01,F
1A36:  BNZ   1974
....................    
....................   do 
....................      { 
....................         clearLCD(); 
1A38:  CALL   0842
....................         lcd_gotoxy(1,1); 
1A3C:  MOVLW  01
1A3E:  MOVWF  xE0
1A40:  MOVWF  xE1
1A42:  CALL   067E
....................         printf(lcd_putc,"Gravando dados..."); 
1A46:  CLRF   xCE
1A48:  MOVF   xCE,W
1A4A:  CALL   03A6
1A4E:  INCF   xCE,F
1A50:  MOVWF  00
1A52:  MOVWF  xDF
1A54:  CALL   07BE
1A58:  MOVLW  11
1A5A:  SUBWF  xCE,W
1A5C:  BNZ   1A48
....................         delay_ms(1000); 
1A5E:  MOVLW  04
1A60:  MOVWF  xCE
1A62:  MOVLW  FA
1A64:  MOVWF  xE8
1A66:  CALL   05A2
1A6A:  DECFSZ xCE,F
1A6C:  BRA    1A62
....................          
....................         zigbee_Write(); 
1A6E:  BRA    194A
....................         esperaPacote(); 
1A70:  CALL   09F8
....................          
....................         clearLCD(); 
1A74:  CALL   0842
....................         lcd_gotoxy(1,1); 
1A78:  MOVLW  01
1A7A:  MOVWF  xE0
1A7C:  MOVWF  xE1
1A7E:  CALL   067E
....................         printf(lcd_putc,"Resp Recebida"); 
1A82:  CLRF   xCE
1A84:  MOVF   xCE,W
1A86:  CALL   0250
1A8A:  INCF   xCE,F
1A8C:  MOVWF  00
1A8E:  MOVWF  xDF
1A90:  CALL   07BE
1A94:  MOVLW  0D
1A96:  SUBWF  xCE,W
1A98:  BNZ   1A84
....................         lcd_gotoxy(1,2); 
1A9A:  MOVLW  01
1A9C:  MOVWF  xE0
1A9E:  MOVLW  02
1AA0:  MOVWF  xE1
1AA2:  CALL   067E
....................         printf(lcd_putc,"%s", pacoteRecebido); 
1AA6:  CLRF   FEA
1AA8:  MOVLW  52
1AAA:  MOVWF  FE9
1AAC:  MOVLW  00
1AAE:  IORWF  FEF,W
1AB0:  BZ    1AD2
1AB2:  MOVFF  FEA,CF
1AB6:  MOVFF  FE9,CE
1ABA:  MOVFF  FEF,DF
1ABE:  CALL   07BE
1AC2:  MOVFF  CF,FEA
1AC6:  MOVFF  CE,FE9
1ACA:  INCF   FE9,F
1ACC:  BTFSC  FD8.2
1ACE:  INCF   FEA,F
1AD0:  BRA    1AAC
....................         delay_ms(1000); 
1AD2:  MOVLW  04
1AD4:  MOVWF  xCE
1AD6:  MOVLW  FA
1AD8:  MOVWF  xE8
1ADA:  CALL   05A2
1ADE:  DECFSZ xCE,F
1AE0:  BRA    1AD6
....................      }while ( strcmp( pacoteRecebido, stringOK) != 0 ); 
1AE2:  CLRF   xDE
1AE4:  MOVLW  52
1AE6:  MOVWF  xDD
1AE8:  CLRF   xE0
1AEA:  MOVLW  9D
1AEC:  MOVWF  xDF
1AEE:  CALL   0A14
1AF2:  MOVF   01,F
1AF4:  BNZ   1A38
....................    
....................   delay_ms(2000); // para ir para modo transparente 
1AF6:  MOVLW  08
1AF8:  MOVWF  xCE
1AFA:  MOVLW  FA
1AFC:  MOVWF  xE8
1AFE:  CALL   05A2
1B02:  DECFSZ xCE,F
1B04:  BRA    1AFA
.................... } 
1B06:  GOTO   1E36 (RETURN)
.................... void enviarComandoRemoto() 
.................... { 
....................    char respostaComando[15]; 
....................    modoComando(); 
1B0A:  CALL   0A88
....................    printf("%s",pacoteStruct.informacao); 
1B0E:  CLRF   FEA
1B10:  MOVLW  B1
1B12:  MOVWF  FE9
1B14:  MOVLW  00
1B16:  IORWF  FEF,W
1B18:  BZ    1B2A
1B1A:  MOVF   FEF,W
1B1C:  BTFSS  F9E.4
1B1E:  BRA    1B1C
1B20:  MOVWF  FAD
1B22:  INCF   FE9,F
1B24:  BTFSC  FD8.2
1B26:  INCF   FEA,F
1B28:  BRA    1B14
....................    putc(0x0d);//envia o '/r' 
1B2A:  MOVLW  0D
1B2C:  BTFSS  F9E.4
1B2E:  BRA    1B2C
1B30:  MOVWF  FAD
....................    esperaPacote(); 
1B32:  CALL   09F8
....................    strcpy(respostaComando, pacoteRecebido); 
1B36:  CLRF   FEA
1B38:  MOVLW  CE
1B3A:  MOVWF  FE9
1B3C:  CLRF   FE2
1B3E:  MOVLW  52
1B40:  MOVWF  FE1
1B42:  MOVF   FE7,F
1B44:  MOVFF  FE6,FEE
1B48:  BNZ   1B42
....................    modoTransparente(); 
1B4A:  CALL   0B9A
....................    printf("#RESPRC*%s",respostaComando); 
1B4E:  CLRF   xDD
1B50:  MOVF   xDD,W
1B52:  CALL   03D2
1B56:  INCF   xDD,F
1B58:  MOVWF  00
1B5A:  MOVF   00,W
1B5C:  BTFSS  F9E.4
1B5E:  BRA    1B5C
1B60:  MOVWF  FAD
1B62:  MOVLW  08
1B64:  SUBWF  xDD,W
1B66:  BNZ   1B50
1B68:  CLRF   FEA
1B6A:  MOVLW  CE
1B6C:  MOVWF  FE9
1B6E:  MOVLW  00
1B70:  IORWF  FEF,W
1B72:  BZ    1B84
1B74:  MOVF   FEF,W
1B76:  BTFSS  F9E.4
1B78:  BRA    1B76
1B7A:  MOVWF  FAD
1B7C:  INCF   FE9,F
1B7E:  BTFSC  FD8.2
1B80:  INCF   FEA,F
1B82:  BRA    1B6E
.................... } 
1B84:  GOTO   1E3C (RETURN)
....................  
.................... void imprimirLeiturasLCD() 
.................... { 
....................    clearLCD(); 
*
18DE:  CALL   0842
....................    lcd_gotoxy(1,1); 
18E2:  MOVLW  01
18E4:  MOVWF  xE0
18E6:  MOVWF  xE1
18E8:  CALL   067E
....................    printf(lcd_putc,"LEITURAs"); 
18EC:  CLRF   xCE
18EE:  MOVF   xCE,W
18F0:  CALL   03F8
18F4:  INCF   xCE,F
18F6:  MOVWF  00
18F8:  MOVWF  xDF
18FA:  CALL   07BE
18FE:  MOVLW  08
1900:  SUBWF  xCE,W
1902:  BNZ   18EE
.................... } 
1904:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... //FIM DAS FUNÇÕES UTILIZADAS PELO MAIN// 
.................... ////////////////////////////////////////////////////////////////// 
.................... //---------------------------------------------------------------------- 
.................... ////////////////////////////////////////////////////////////////// 
.................... //MAIN// 
.................... ////////////////////////////////////////////////////////////////// 
.................... void main(void){ //while(1) ;} 
*
1B88:  CLRF   FF8
1B8A:  BCF    FD0.7
1B8C:  BSF    0D.7
1B8E:  CLRF   FEA
1B90:  CLRF   FE9
1B92:  BSF    FB8.3
1B94:  MOVLW  08
1B96:  MOVWF  FAF
1B98:  MOVLW  02
1B9A:  MOVWF  FB0
1B9C:  MOVLW  A6
1B9E:  MOVWF  FAC
1BA0:  MOVLW  90
1BA2:  MOVWF  FAB
1BA4:  MOVF   FC1,W
1BA6:  ANDLW  C0
1BA8:  IORLW  0F
1BAA:  MOVWF  FC1
1BAC:  MOVLW  07
1BAE:  MOVWF  FB4
1BB0:  CLRF   19
1BB2:  CLRF   1A
1BB4:  CLRF   1B
1BB6:  CLRF   x87
1BB8:  CLRF   x88
....................   //--------------INICIALIZAÇÃO-------------------// 
....................   quantidadePacotesEnviados = 0; 
1BBA:  CLRF   xAF
....................    
....................   enable_interrupts(GLOBAL); //Habilita interrupção da serial 
1BBC:  MOVLW  C0
1BBE:  IORWF  FF2,F
....................   enable_interrupts(int_rda); 
1BC0:  BSF    F9D.5
....................  
....................   inicializar_variaveis(); //Inicializa variáveis de controle da recepção serial 
1BC2:  GOTO   0528
....................   limpar_buffer(); //Limpa o Buffer de recepção serial 
1BC6:  GOTO   057E
....................    
....................   lcd_init(); 
1BCA:  GOTO   06A0
....................   clearLCD(); 
1BCE:  CALL   0842
....................   lcd_gotoxy(1,1); 
1BD2:  MOVLW  01
1BD4:  MOVWF  xE0
1BD6:  MOVWF  xE1
1BD8:  CALL   067E
....................   printf(lcd_putc,"Inicializando*.*"); 
1BDC:  CLRF   xCE
1BDE:  MOVF   xCE,W
1BE0:  CALL   041C
1BE4:  INCF   xCE,F
1BE6:  MOVWF  00
1BE8:  MOVWF  xDF
1BEA:  CALL   07BE
1BEE:  MOVLW  10
1BF0:  SUBWF  xCE,W
1BF2:  BNZ   1BDE
....................   delay_ms(5000); //espera a inicialização do modulo 
1BF4:  MOVLW  14
1BF6:  MOVWF  xCE
1BF8:  MOVLW  FA
1BFA:  MOVWF  xE8
1BFC:  CALL   05A2
1C00:  DECFSZ xCE,F
1C02:  BRA    1BF8
....................   lcd_gotoxy(1,1); 
1C04:  MOVLW  01
1C06:  MOVWF  xE0
1C08:  MOVWF  xE1
1C0A:  CALL   067E
....................    
....................   sprintf(stringOK, "OK"); 
1C0E:  CLRF   x88
1C10:  MOVLW  9D
1C12:  MOVWF  x87
1C14:  MOVLW  4F
1C16:  MOVWF  xCF
1C18:  CALL   050C
1C1C:  MOVLW  4B
1C1E:  MOVWF  xCF
1C20:  CALL   050C
....................   sprintf(stringDestinationNodeName, "SINK"); 
1C24:  CLRF   x88
1C26:  MOVLW  A0
1C28:  MOVWF  x87
1C2A:  CLRF   xCE
1C2C:  MOVF   xCE,W
1C2E:  CALL   0448
1C32:  INCF   xCE,F
1C34:  MOVWF  00
1C36:  MOVWF  xCF
1C38:  CALL   050C
1C3C:  MOVLW  04
1C3E:  SUBWF  xCE,W
1C40:  BNZ   1C2C
....................   sprintf(keyPassword, "senha"); 
1C42:  CLRF   x88
1C44:  MOVLW  A5
1C46:  MOVWF  x87
1C48:  CLRF   xCE
1C4A:  MOVF   xCE,W
1C4C:  CALL   0468
1C50:  INCF   xCE,F
1C52:  MOVWF  00
1C54:  MOVWF  xCF
1C56:  CALL   050C
1C5A:  MOVLW  05
1C5C:  SUBWF  xCE,W
1C5E:  BNZ   1C4A
....................   //--------------FIM DA INICIALIZAÇÃO-------------------// 
....................    
....................   modoComando(); 
1C60:  CALL   0A88
....................    
....................   //limpar_buffer(); 
....................   zigbee_SerialNumberHigh(); 
1C64:  GOTO   0B30
....................   delay_ms(500); 
1C68:  MOVLW  02
1C6A:  MOVWF  xCE
1C6C:  MOVLW  FA
1C6E:  MOVWF  xE8
1C70:  CALL   05A2
1C74:  DECFSZ xCE,F
1C76:  BRA    1C6C
....................   esperaPacote(); 
1C78:  CALL   09F8
....................   strcopy( enderecoH, pacoteRecebido ); 
1C7C:  CLRF   xFF
1C7E:  MOVLW  89
1C80:  MOVWF  xFE
1C82:  MOVLB  1
1C84:  CLRF   x01
1C86:  MOVLW  52
1C88:  MOVWF  x00
1C8A:  MOVLB  0
1C8C:  CALL   08A0
....................    
....................   //limpar_buffer(); 
....................   zigbee_SerialNumberLow(); 
1C90:  GOTO   0B56
....................   delay_ms(500); 
1C94:  MOVLW  02
1C96:  MOVWF  xCE
1C98:  MOVLW  FA
1C9A:  MOVWF  xE8
1C9C:  CALL   05A2
1CA0:  DECFSZ xCE,F
1CA2:  BRA    1C98
....................   esperaPacote(); 
1CA4:  CALL   09F8
....................   strcopy( enderecoL, pacoteRecebido ); 
1CA8:  CLRF   xFF
1CAA:  MOVLW  93
1CAC:  MOVWF  xFE
1CAE:  MOVLB  1
1CB0:  CLRF   x01
1CB2:  MOVLW  52
1CB4:  MOVWF  x00
1CB6:  MOVLB  0
1CB8:  CALL   08A0
....................    
....................   clearLCD(); 
1CBC:  CALL   0842
....................   lcd_gotoxy(1,1); 
1CC0:  MOVLW  01
1CC2:  MOVWF  xE0
1CC4:  MOVWF  xE1
1CC6:  CALL   067E
....................   printf(lcd_putc,"%s", enderecoH); 
1CCA:  CLRF   FEA
1CCC:  MOVLW  89
1CCE:  MOVWF  FE9
1CD0:  MOVLW  00
1CD2:  IORWF  FEF,W
1CD4:  BZ    1CF6
1CD6:  MOVFF  FEA,CF
1CDA:  MOVFF  FE9,CE
1CDE:  MOVFF  FEF,DF
1CE2:  CALL   07BE
1CE6:  MOVFF  CF,FEA
1CEA:  MOVFF  CE,FE9
1CEE:  INCF   FE9,F
1CF0:  BTFSC  FD8.2
1CF2:  INCF   FEA,F
1CF4:  BRA    1CD0
....................   lcd_gotoxy(1,2); 
1CF6:  MOVLW  01
1CF8:  MOVWF  xE0
1CFA:  MOVLW  02
1CFC:  MOVWF  xE1
1CFE:  CALL   067E
....................   printf(lcd_putc,"%s", enderecoL); 
1D02:  CLRF   FEA
1D04:  MOVLW  93
1D06:  MOVWF  FE9
1D08:  MOVLW  00
1D0A:  IORWF  FEF,W
1D0C:  BZ    1D2E
1D0E:  MOVFF  FEA,CF
1D12:  MOVFF  FE9,CE
1D16:  MOVFF  FEF,DF
1D1A:  CALL   07BE
1D1E:  MOVFF  CF,FEA
1D22:  MOVFF  CE,FE9
1D26:  INCF   FE9,F
1D28:  BTFSC  FD8.2
1D2A:  INCF   FEA,F
1D2C:  BRA    1D08
....................   delay_ms(1000); 
1D2E:  MOVLW  04
1D30:  MOVWF  xCE
1D32:  MOVLW  FA
1D34:  MOVWF  xE8
1D36:  CALL   05A2
1D3A:  DECFSZ xCE,F
1D3C:  BRA    1D32
....................    
....................   modoTransparente( ); 
1D3E:  CALL   0B9A
....................    
....................   setarDesstinoConcentrador(); 
1D42:  CALL   0C94
....................    
....................   init_ADC(); 
1D46:  GOTO   0D44
....................    
....................   clearLCD(); 
1D4A:  CALL   0842
....................   lcd_gotoxy(1,1); 
1D4E:  MOVLW  01
1D50:  MOVWF  xE0
1D52:  MOVWF  xE1
1D54:  CALL   067E
....................   printf(lcd_putc,"LEITURAs"); 
1D58:  CLRF   xCE
1D5A:  MOVF   xCE,W
1D5C:  CALL   03F8
1D60:  INCF   xCE,F
1D62:  MOVWF  00
1D64:  MOVWF  xDF
1D66:  CALL   07BE
1D6A:  MOVLW  08
1D6C:  SUBWF  xCE,W
1D6E:  BNZ   1D5A
....................   delay_ms(1000); 
1D70:  MOVLW  04
1D72:  MOVWF  xCE
1D74:  MOVLW  FA
1D76:  MOVWF  xE8
1D78:  CALL   05A2
1D7C:  DECFSZ xCE,F
1D7E:  BRA    1D74
....................    
....................   while(1) 
....................   { 
....................       clearLine2(); 
1D80:  CALL   0822
....................       ler_canal_AD_para_puint8 (0, valorStringLeituraAD); 
1D84:  CLRF   xCF
1D86:  CLRF   xD1
1D88:  MOVLW  C4
1D8A:  MOVWF  xD0
1D8C:  CALL   1056
....................       lcd_gotoxy(1,2); 
1D90:  MOVLW  01
1D92:  MOVWF  xE0
1D94:  MOVLW  02
1D96:  MOVWF  xE1
1D98:  CALL   067E
....................       printf(lcd_putc,"%s -", valorStringLeituraAD); 
1D9C:  CLRF   FEA
1D9E:  MOVLW  C4
1DA0:  MOVWF  FE9
1DA2:  MOVLW  00
1DA4:  IORWF  FEF,W
1DA6:  BZ    1DC8
1DA8:  MOVFF  FEA,CF
1DAC:  MOVFF  FE9,CE
1DB0:  MOVFF  FEF,DF
1DB4:  CALL   07BE
1DB8:  MOVFF  CF,FEA
1DBC:  MOVFF  CE,FE9
1DC0:  INCF   FE9,F
1DC2:  BTFSC  FD8.2
1DC4:  INCF   FEA,F
1DC6:  BRA    1DA2
1DC8:  MOVLW  20
1DCA:  MOVWF  xDF
1DCC:  CALL   07BE
1DD0:  MOVLW  2D
1DD2:  MOVWF  xDF
1DD4:  CALL   07BE
....................       ler_canal_AD_para_int32 (1, &valorLeituraAD); 
1DD8:  MOVLW  01
1DDA:  MOVWF  xCE
1DDC:  CLRF   xD0
1DDE:  MOVLW  C0
1DE0:  MOVWF  xCF
1DE2:  GOTO   10A2
....................       printf(lcd_putc,"- %Lu", valorLeituraAD); 
1DE6:  MOVLW  2D
1DE8:  MOVWF  xDF
1DEA:  CALL   07BE
1DEE:  MOVLW  20
1DF0:  MOVWF  xDF
1DF2:  CALL   07BE
1DF6:  MOVLW  41
1DF8:  MOVWF  FE9
1DFA:  MOVFF  C3,D1
1DFE:  MOVFF  C2,D0
1E02:  MOVFF  C1,CF
1E06:  MOVFF  C0,CE
1E0A:  GOTO   1158
....................        
....................       if (chegouPacote() == 1) 
1E0E:  CALL   090E
1E12:  DECFSZ 01,W
1E14:  BRA    1E40
....................       { 
....................          tratarPacote(&pacoteStruct); 
1E16:  CLRF   xCF
1E18:  MOVLW  B0
1E1A:  MOVWF  xCE
1E1C:  GOTO   1206
....................          switch (pacoteStruct.tipoPacote) 
....................          { 
1E20:  MOVF   xB0,W
1E22:  BZ    1E2E
1E24:  XORLW  01
1E26:  BZ    1E34
1E28:  XORLW  03
1E2A:  BZ    1E3A
1E2C:  BRA    1E40
....................             case READR: 
....................                enviarLeitura(); 
1E2E:  RCALL  180A
....................                imprimirLeiturasLCD(); 
1E30:  RCALL  18DE
....................                break; 
1E32:  BRA    1E40
....................             case SET_NAME: 
....................                setarNomeDevice(); 
1E34:  BRA    1970
....................                imprimirLeiturasLCD(); 
1E36:  RCALL  18DE
....................                break; 
1E38:  BRA    1E40
....................             case COMANDO_REMOTO: 
....................                enviarComandoRemoto(); 
1E3A:  BRA    1B0A
....................                imprimirLeiturasLCD(); 
1E3C:  RCALL  18DE
....................                break; 
1E3E:  BRA    1E40
....................             default: 
....................                //faz nada 
....................          } 
....................       } 
....................       if(valorLeituraAD < 500) 
1E40:  MOVF   xC3,F
1E42:  BNZ   1E5A
1E44:  MOVF   xC2,F
1E46:  BNZ   1E5A
1E48:  MOVF   xC1,W
1E4A:  SUBLW  01
1E4C:  BNC   1E5A
1E4E:  BNZ   1E56
1E50:  MOVF   xC0,W
1E52:  SUBLW  F3
1E54:  BNC   1E5A
....................       { 
....................          enviarLeitura(); 
1E56:  RCALL  180A
....................          imprimirLeiturasLCD(); 
1E58:  RCALL  18DE
....................       } 
....................          
....................       delay_ms(1000); 
1E5A:  MOVLW  04
1E5C:  MOVWF  xCE
1E5E:  MOVLW  FA
1E60:  MOVWF  xE8
1E62:  CALL   05A2
1E66:  DECFSZ xCE,F
1E68:  BRA    1E5E
....................     
....................   } 
1E6A:  BRA    1D80
....................  
.................... } 
.................... ////////////////////////////////////////////////////////////////// 
.................... //FIM DO MAIN// 
.................... ////////////////////////////////////////////////////////////////// 
1E6C:  SLEEP 

Configuration Fuses:
   Word  1: 0C20   NOIESO NOFCMEN HS PLL1 CPUDIV1 USBDIV
   Word  2: 1E18   NOBROWNOUT NOWDT BORV20 PUT WDT32768 NOVREGEN RESERVED
   Word  3: 8300   PBADEN CCP2C1 MCLR NOLPT1OSC RESERVED
   Word  4: 0001   STVREN DEBUG NOLVP NOXINST NOICPRT RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
